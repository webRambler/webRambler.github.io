<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CORS缓存options预检请求</title>
    <url>/2022/01/01/CORS%E7%BC%93%E5%AD%98options%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="CORS缓存options预检请求"><a href="#CORS缓存options预检请求" class="headerlink" title="CORS缓存options预检请求"></a>CORS缓存options预检请求</h2><p>增加响应头Access-Control-max-age即可，这样在一定的时间内，后续请求就不会再去发options预检请求了。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的let到底存不存在变量提升</title>
    <url>/2021/12/12/ES6%E7%9A%84let%E5%88%B0%E5%BA%95%E5%AD%98%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于ES6中的let存不存在变量提升的问题，我想大部分人都认为是不存在变量提升的，而官方文档关于这点也曾做过改动，最初是认为存在变量提升，后来又改成了不存在变量提升。而最近我在CSDN上看到一篇文章在探讨这个问题，于是自己就试验了一下。实践是检验真理的唯一标准，那么今天我们就来探讨一下到底let存不存在变量提升的问题。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p><strong>定义：函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。</strong></p>
<p>通过定义我们可以知道，只有变量的声明和函数的声明存在变量提升这一说，那么在ES6出现之前，JavaScript声明变量的方式是通过关键字var实现的，声明函数自然通过function啦，ES6中我们用let，const来声明变量和常量。</p>
<p>话不多说，直接上一段代码： <code>&#123; console.log(a) // 报错，a is not defined let a=2; &#125;</code></p>
<hr>
<p>这和官方文档所说的存在暂时性死区是一致的。<br>如果let存在变量提升，那么上述代码就相当于下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; let a; console.log(a) //undefined a=2; &#125;```  </span><br><span class="line"> 由此可见，let并不存在变量提升。此外，ES6新增了块级作用域的概念，块级作用域简单的来说就是用&#123;&#125;包裹起来的就是块级作用域。不妨再来看一个例子：  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>{ let a =11; console.log(a); //11 }```</p>
<p>console.log(a); //报错，a is not defined<br>因此，我们可以得出结论，let声明的变量不能跨块访问。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作大全</title>
    <url>/2021/12/31/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>下面我们说一说Git常见的操作</p>
<h2 id="git-config-常用配置"><a href="#git-config-常用配置" class="headerlink" title="git config 常用配置"></a>git config 常用配置</h2><p>配置邮箱和用户名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 全局配置</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 单个项目配置（先进入项目的根目录，带有.git隐藏文件的目录）</span></span><br><span class="line">git config user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line"><span class="comment">## 对单个项目进行配置可覆盖全局配置</span></span><br></pre></td></tr></table></figure>

<p>配置命令别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 比如给 git status 设置别名 st:</span></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>查看已有配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line"><span class="comment">## 或者</span></span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure>
<h2 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h2><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。</p>
<p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment">## 该命令执行完后会在当前目录生成一个 .git 目录。</span></span><br></pre></td></tr></table></figure>
<p>使用我们指定目录作为Git仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init projectPath</span><br></pre></td></tr></table></figure>
<p>初始化后，会在 projectPath目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<h2 id="克隆仓库代码"><a href="#克隆仓库代码" class="headerlink" title="克隆仓库代码"></a>克隆仓库代码</h2><p>克隆代码到当前文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址 目标文件夹</span><br></pre></td></tr></table></figure>
<h2 id="提交三部曲"><a href="#提交三部曲" class="headerlink" title="提交三部曲"></a>提交三部曲</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>git add . 提交工作区改动到暂存区；</p>
<p>git commit -m “message” 提交暂存区到本地仓库；</p>
<p>commit完之后要记得git pull更新一下最新的远程仓库代码到本地；</p>
<p>最后确保没有冲突没有报错的情况下git push 提交本地修改到远程仓库；</p>
<h2 id="撤销工作区变更的文件"><a href="#撤销工作区变更的文件" class="headerlink" title="撤销工作区变更的文件"></a>撤销工作区变更的文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- filename (前提， filename 已在仓库中)</span><br><span class="line"><span class="comment">#-- 代表“ 无论如何，将其之后的 argument 视为一个文件名（filename）”</span></span><br></pre></td></tr></table></figure>
<h2 id="从暂存区撤销回工作区"><a href="#从暂存区撤销回工作区" class="headerlink" title="从暂存区撤销回工作区"></a>从暂存区撤销回工作区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD -- filename</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status    <span class="comment">#查看当前状态</span></span><br><span class="line">git add &lt;filename&gt;    <span class="comment">#提交文件到暂存区</span></span><br><span class="line">git add .     <span class="comment">#提交所有工作区改动到暂存区</span></span><br><span class="line">git <span class="built_in">log</span>    <span class="comment">#查看提交记录</span></span><br><span class="line">git <span class="built_in">log</span> --graph    <span class="comment">#查看分支图合并</span></span><br><span class="line">git reflog    <span class="comment">#查看近期所有操作提交记录</span></span><br><span class="line">git branch -l   <span class="comment">#查看本地仓库分支 </span></span><br><span class="line">git branch -al     <span class="comment">#查看所有分支(包含本地分支和远程分支)</span></span><br><span class="line">git checkout [分支名]    <span class="comment">#切换分支</span></span><br><span class="line">git checkout -b [分支名] [远程分支]    <span class="comment">#基于某个远程分支新建分支并切换到该分支</span></span><br><span class="line">git branch -d [分支名]    <span class="comment">#删除某分支</span></span><br><span class="line">git merge [分支名]    <span class="comment">#分支进行融合</span></span><br><span class="line">git remote    <span class="comment">#查看远程库信息 -v 详细信息</span></span><br><span class="line">git tag    <span class="comment">#查看本地仓库所有标签</span></span><br><span class="line">git tag &lt;name&gt; &lt;commitId&gt;    <span class="comment">#默认HEAD打一个标签 可指定特定commitId -m &#x27;为标签添加注释&#x27;</span></span><br><span class="line">git tag -d &lt;tagName&gt;    <span class="comment">#删除某个标签</span></span><br><span class="line">git push -d origin &lt;tagName&gt;    <span class="comment">#删除远程标签</span></span><br><span class="line">git push --tags    <span class="comment">#将本地标签一次性推送到远程</span></span><br><span class="line">git push origin &lt;tagName&gt;    <span class="comment">#推送指定标签到远程</span></span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="1-git-branch"><a href="#1-git-branch" class="headerlink" title="1.git branch"></a>1.git branch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -l    <span class="comment">#查看本地分支列表</span></span><br><span class="line">git branch -a    <span class="comment">#查看所有分支列表（包含本地分支和远程分支）</span></span><br><span class="line">git branch 分支名xx    <span class="comment">#创建分支xx</span></span><br><span class="line">git branch -d 分支名xx    <span class="comment">#删除本地xx分支</span></span><br><span class="line">git branch --merged    <span class="comment">#它列出了已合并到当前分支的分支</span></span><br><span class="line">git branch –no-merged    <span class="comment">#它列出了尚未合并的分支</span></span><br><span class="line">git branch dev master     <span class="comment">#从 master 分支下创建 dev 分支</span></span><br><span class="line">git branch -m dev DEV     <span class="comment">#修改 dev 分支名称为 DEV 分支</span></span><br></pre></td></tr></table></figure>
<h3 id="2-git-checkout"><a href="#2-git-checkout" class="headerlink" title="2.git checkout"></a>2.git checkout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 分支名xx    <span class="comment">#切换到xx分支</span></span><br><span class="line">git checkout -b 分支名xx    <span class="comment">#创建xx分支并切换到该分支</span></span><br><span class="line">git checkout 分支名xx --force    <span class="comment">#强制切换分支xx, 修改的工作区不会被清除</span></span><br><span class="line">git checkout -b local_branch origin/remote_branch    <span class="comment">#从远程分支remote_branch拉取到本地local_branch, 然后切换到local_branch, 并且建立映射关系</span></span><br><span class="line">git checkout branch_name -- filename    <span class="comment">#从别的分支拉取文件到本的分支指定文件</span></span><br></pre></td></tr></table></figure>
<h3 id="3-git-merge"><a href="#3-git-merge" class="headerlink" title="3.git merge"></a>3.git merge</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge 分支名xx    <span class="comment">#合并xx分支到当前分支</span></span><br><span class="line">git merge --abort    <span class="comment">#执行合并时, 出现冲突文件, 执行操作退回未合并的状态</span></span><br><span class="line">git merge --<span class="built_in">continue</span>    <span class="comment">#执行合并时, 出现冲突文件, 修改冲突文件, 并且执行git add, 则继续合并</span></span><br><span class="line">git merge feature-a feature-b    <span class="comment">#快速合并两个分支，同时非快速合并当前分支</span></span><br><span class="line">git merge --no-commit feature-a    <span class="comment">#合并feature-a分支，但不产生一个commit 提交</span></span><br><span class="line">git merge --squash brantch_0    <span class="comment">#会把brantch_0的所有改动都放在当前分支但是并不会提交，本地会显示有东西未add需要手动commit，但是因为手动add，commit后在brantch_0的所有修改记录的修改人都会变成你自己，在提交记录上只会有一个提交记录。</span></span><br></pre></td></tr></table></figure>
<h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4.其它"></a>4.其它</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete 分支名xx    <span class="comment">#删除远程分支xx</span></span><br></pre></td></tr></table></figure>
<h2 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset commit_id    <span class="comment">#修改的内容都处于工作区状态</span></span><br><span class="line">git reset --soft commit_id     <span class="comment">#修改的内容都处于暂存区状态</span></span><br><span class="line">git reset --hard commit_id    <span class="comment">#版本库完全替换工作区（慎用）</span></span><br><span class="line">git revert -n commit_id  <span class="comment">#撤销某一次提交，HEAD继续往前走，用一次新的commit来反做旧的commit</span></span><br></pre></td></tr></table></figure>

<h2 id="合并其他分支的某次提交"><a href="#合并其他分支的某次提交" class="headerlink" title="合并其他分支的某次提交"></a>合并其他分支的某次提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff]</span><br><span class="line">		  [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git cherry-pick (--<span class="built_in">continue</span> | --skip | --abort | --quit)</span><br><span class="line">git cherry-pick commit_id  <span class="comment">#简单用法</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码详解</title>
    <url>/2021/12/12/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p>
<p>状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端是正常处理了请求，还是出现了错误。</p>
<h2 id="HTTP状态码的类别及原因短语"><a href="#HTTP状态码的类别及原因短语" class="headerlink" title="HTTP状态码的类别及原因短语"></a>HTTP状态码的类别及原因短语</h2><table>
<thead>
<tr>
<th>code</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<hr>
<p>接下来我们来详细的说一说常见的HTTP状态码。</p>
<h2 id="1-200-OK"><a href="#1-200-OK" class="headerlink" title="1.200 OK"></a>1.200 OK</h2><p>表示从客户端发送的请求在服务端被正常的处理了。</p>
<h2 id="2-204-No-Content"><a href="#2-204-No-Content" class="headerlink" title="2.204 No Content"></a>2.204 No Content</h2><p>表示服务器接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。此种响应一般用在只需要从客户端发送信息给服务端，而服务端不需要返回新信息内容给客户端时使用。</p>
<h2 id="3-206-Partial-Content"><a href="#3-206-Partial-Content" class="headerlink" title="3.206 Partial Content"></a>3.206 Partial Content</h2><p>表示客户端进行了范围请求，而服务端成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
<h2 id="4-301-Moved-Permanently"><a href="#4-301-Moved-Permanently" class="headerlink" title="4.301 Moved Permanently"></a>4.301 Moved Permanently</h2><p>永久性重定向，表示请求的资源以及被分配了新的URI，以后应该使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</p>
<h2 id="5-302-Found"><a href="#5-302-Found" class="headerlink" title="5.302 Found"></a>5.302 Found</h2><p>临时性重定向，表示请求的资源以及被分配了新的URI，本次访问应该使用资源现在所指的URI。该状态码表示资源只是被临时移动，而不是永久性移动。</p>
<h2 id="6-303-See-Other"><a href="#6-303-See-Other" class="headerlink" title="6.303 See Other"></a>6.303 See Other</h2><p>表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取资源请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源。</p>
<p>此外，当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。301，302状态码的标准是禁止将POST改成GET方法的，但实际使用时大家都会这么做。</p>
<h2 id="7-304-Not-Modified"><a href="#7-304-Not-Modified" class="headerlink" title="7.304 Not Modified"></a>7.304 Not Modified</h2><p>该状态码表示客户端发送附带条件的请求（附带条件的请求是指采用GET方法的请求报文中包含If-Match，If-Modified-since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）时，服务端允许请求访问资源，但因发生请求未满足条件的情况下，直接返回304Not Modified(服务端资源未改变，可直接使用客户端未过期的缓存)。</p>
<h2 id="8-307-Temporary-Redirect"><a href="#8-307-Temporary-Redirect" class="headerlink" title="8.307 Temporary Redirect"></a>8.307 Temporary Redirect</h2><p>临时重定向，该状态码与302有着相同的含义。尽管302标准禁止将POST改为GET，但实际使用时大家并不遵守。307会遵守浏览器标准，不会从POST改为GET。</p>
<h2 id="9-400-Bad-Request"><a href="#9-400-Bad-Request" class="headerlink" title="9.400 Bad Request"></a>9.400 Bad Request</h2><p>该状态码表示请求报文中存在语法错误，当错误发生时，需要修改请求的内容后再次发送请求。另外，浏览器会像对待200状态码一样对待该状态码。</p>
<h2 id="10-401-Unauthorized"><a href="#10-401-Unauthorized" class="headerlink" title="10.401 Unauthorized"></a>10.401 Unauthorized</h2><p>表示发送的请求需要通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败。</p>
<p>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p>
<h2 id="11-403-Forbidden"><a href="#11-403-Forbidden" class="headerlink" title="11.403 Forbidden"></a>11.403 Forbidden</h2><p>表示请求的资源访问被服务器拒绝了。服务端没有必要各处拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p>
<p>未获得文件系统的访问权限，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。</p>
<h2 id="12-404-Not-Found"><a href="#12-404-Not-Found" class="headerlink" title="12.404 Not Found"></a>12.404 Not Found</h2><p>表示服务器上无法找到请求的资源。此外，也可以在服务端拒绝请求且不想说明理由时使用。</p>
<h2 id="13-500-Internal-Server-Error"><a href="#13-500-Internal-Server-Error" class="headerlink" title="13.500 Internal Server Error"></a>13.500 Internal Server Error</h2><p>表示服务端在执行某些请求时发生了错误。也有可能时web应用存在的bug或某些临时的故障。</p>
<h2 id="14-501"><a href="#14-501" class="headerlink" title="14.501"></a>14.501</h2><p>服务器501错误是服务器还是不具有请求功能的，而且501错误原因是没有实施的，可以用来HttpWebRequest指定一个UserAgent来试试的，有时候你可以换电脑来测试一下的。</p>
<h2 id="15-502-Bad-Gateway"><a href="#15-502-Bad-Gateway" class="headerlink" title="15.502 Bad Gateway"></a>15.502 Bad Gateway</h2><p>这是服务器上的一个错误网关 ，因此说它是无效的，我们在出现了服务器502错误问题的时候，最好是先清除下缓存或者是在服务器上进行刷新试试的，因为502错误牵扯的问题也是很多的，最好是让程序们来去在服务器上下文章。</p>
<h2 id="16-503-Service-Unavailable"><a href="#16-503-Service-Unavailable" class="headerlink" title="16.503 Service Unavailable"></a>16.503 Service Unavailable</h2><p>表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p>
<h2 id="17-504-Gateway-Timeout"><a href="#17-504-Gateway-Timeout" class="headerlink" title="17.504 Gateway Timeout"></a>17.504 Gateway Timeout</h2><p>这是代表着网关超时是现象出现了。504错误问题是一个不好办的问题，当然你必须尝试着和网站官方获得联系，认真的去检查不同的电脑简的ip传输的状况。而且这个504错误要专业的负责人才能去解决。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件委托</title>
    <url>/2021/12/13/JS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h2 id="DOM的事件流程"><a href="#DOM的事件流程" class="headerlink" title="DOM的事件流程"></a>DOM的事件流程</h2><p>DOM的事件流程分为三个阶段：<strong>事件捕获阶段</strong>、<strong>处于目标阶段</strong>、<strong>事件冒泡阶段</strong>。</p>
<ol>
<li>首先发生的是事件捕获，为截获事件提供了机会。</li>
<li>然后是实际的目标接收到事件。</li>
<li>然后冒泡阶段发生，事件又传播回文档。</li>
</ol>
<h3 id="第一阶段：事件捕获。"><a href="#第一阶段：事件捕获。" class="headerlink" title="第一阶段：事件捕获。"></a>第一阶段：事件捕获。</h3><p>所谓的事件捕获就是从最大范围（document）开始，一级一级往下找，知道找到最精确的事件源（触发事件的节点，如图div节点）为止的过程。虽然大多数浏览器都支持事件捕获，但很少有人使用。<br><a href="https://img-blog.csdnimg.cn/20190311002653424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190311002653424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<h3 id="第二阶段：事件触发。"><a href="#第二阶段：事件触发。" class="headerlink" title="第二阶段：事件触发。"></a>第二阶段：事件触发。</h3><p>找到了事件源，接下来就应当执行绑定的相应的事件（如果有的话）。</p>
<h3 id="第三阶段：事件冒泡。"><a href="#第三阶段：事件冒泡。" class="headerlink" title="第三阶段：事件冒泡。"></a>第三阶段：事件冒泡。</h3><p>事件源执行完事件处理后。这个类型的事件会向祖先节点传递，直到document（包括document）（当然是在事件冒泡没有被阻止的前提下，后续的分析都是基于这个前提下）。也就是说事件源的每一个祖先节点都会触发同类事件。<br><a href="https://img-blog.csdnimg.cn/20190311002434820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190311002434820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>想象一下，把事件源a触发click事件的处理委托给其祖先节点b。当a节点触发click,事件冒泡到b的时候，b节点也触发click事件，然后b一看事件列表中有一个委托事件，这个委托事件保存了委托节点的选择器，这个选择器所匹配节点就是事件源a,那么b马上执行这个委托事件。</p>
<h2 id="什么是事件委托？"><a href="#什么是事件委托？" class="headerlink" title="什么是事件委托？"></a>什么是事件委托？</h2><p>事件委托——利用事件冒泡机制，给祖先元素绑定事件，用来监听子元素的事件，将子元素的事件要做的事写到祖先元素的事件里，也就是将子元素的事件处理程序写到祖先元素的事件处理程序中。</p>
<p>事件委托的好处：</p>
<p>（1）事件委托技术可以避免对每个字元素添加事件监听器，减少操作DOM节点的次数，从而减少浏览器的重绘和重排，提高代码的性能。</p>
<p>设想一下，假如一个div元素的子元素中有成百上千个a标签，然后，我们要监听a标签的点击事件，如果在每个a标签上绑定元素，那么量多么大的工作，而且如果是动态添加的元素，我们还无法做到正确的监听，但是有了时间委托技术，我们完全可以在其祖先元素div上监听点击事件，然后判断事件触发的源头，进而去执行相应的事件处理程序，即可满足需求。如此，减少操作DOM节点的次数，从而减少浏览器的重绘和重排，提高了代码的性能。</p>
<p>（2）使用事件委托，只有父元素与DOM存在交互，其他的操作都是在JS虚拟内存中完成的，这样就大大提高了性能。</p>
<p>什么时候用事件委托？</p>
<p>一般情况下，当子元素有很多（或者说有大量子元素来自于于动态增删的时候），并且需要对子元素的事件进行监听的时候，这时候，我们推荐使用事件委托。</p>
<h2 id="事件委托的实现"><a href="#事件委托的实现" class="headerlink" title="事件委托的实现"></a>事件委托的实现</h2><p>直接看代码吧：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;big&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;small&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      <span class="selector-id">#big</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#middle</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">25%</span> auto;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#small</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">25%</span> auto;</span><br><span class="line">        <span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> big = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    big.eventList = []</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;middle&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> small = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    big.eventList.push(&#123;<span class="attr">trigger</span>:small2, <span class="attr">target</span>: small&#125;)</span><br><span class="line">    big.eventList.push(&#123;<span class="attr">trigger</span>:middle2, <span class="attr">target</span>: middle&#125;)</span><br><span class="line"></span><br><span class="line">    big.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;big clicked!&quot;</span>)</span><br><span class="line">      <span class="built_in">this</span>.eventList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.target === e.target) &#123;</span><br><span class="line">          element.trigger()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">middle2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;middle clicked!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">small2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;small clicked!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>页面展示如下：<br><a href="https://img-blog.csdnimg.cn/20190311004745600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190311004745600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>当我们点击最外层big元素的时候，输出如下：<br><a href="https://img-blog.csdnimg.cn/20190311004843616.png"><img src="https://img-blog.csdnimg.cn/20190311004843616.png"></a></p>
<p>很明显的可以看到，只有big绑定的click事件的事件处理程序执行了。</p>
<p>当我们点击最内层的small元素时，输出如下：<br><a href="https://img-blog.csdnimg.cn/20190311005016843.png"><img src="https://img-blog.csdnimg.cn/20190311005016843.png"></a></p>
<p>可以很明显的看到我们想要的当small元素被点击时，samll2函数被触发，而此时click事件绑定在small元素的祖先元素big上面，由此就实现了事件委托。</p>
<p>同理，可以实现，点击middle元素，利用事件委托将click事件绑定在其父元素big元素上，进而当middle被点击时，触发middle2函数。</p>
<p>当点击middle元素时，输出如下：<br><a href="https://img-blog.csdnimg.cn/20190311005431282.png"><img src="https://img-blog.csdnimg.cn/20190311005431282.png"></a></p>
<p>由此，我们就简单的模拟实现了事件委托，可以很明显的发现，实现事件委托的主要手段是利用事件冒泡机制加上事件对象的target属性判断事件触发的源头，进而实现事件委托。需要提醒大家的是，IE浏览器的事件对象并不支持target属性，在IE中对应的是srcElement，这一点请大家注意。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中构造函数中有return的分析</title>
    <url>/2021/12/13/JS%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E6%9C%89return%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>简单的总结来说就一句话：如果return的值是基本数据类型的话，则忽略return，直接返回实例化的对象；如果return的值是引用类型的话，则不再返回实例化的对象，而是直接返回return返回的引用类型的值。</p>
<h2 id="demo帮助理解"><a href="#demo帮助理解" class="headerlink" title="demo帮助理解"></a>demo帮助理解</h2><p>看几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name</span><br><span class="line">   <span class="keyword">return</span> <span class="number">12306</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>
<p>此种情况下，会忽略return后面的12306，而直接返回Person的实例化对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">age</span>: <span class="number">26</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name</span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>
<p>此种情况下，由于return的值是一个对象，所以p的值最后会是返回的对象，即obj.</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件对象(event)的一些兼容性写法</title>
    <url>/2021/12/12/JS%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-event-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h2 id="获得event对象兼容性写法"><a href="#获得event对象兼容性写法" class="headerlink" title="获得event对象兼容性写法"></a>获得event对象兼容性写法</h2><pre><code>event || (event = window.event);
</code></pre>
<h2 id="获得target兼容型写法"><a href="#获得target兼容型写法" class="headerlink" title="获得target兼容型写法"></a>获得target兼容型写法</h2><pre><code>event.target||event.srcElement
</code></pre>
<h2 id="阻止浏览器默认行为兼容性写法"><a href="#阻止浏览器默认行为兼容性写法" class="headerlink" title="阻止浏览器默认行为兼容性写法"></a>阻止浏览器默认行为兼容性写法</h2><pre><code>event.preventDefault ? event.preventDefault() : (event.returnValue = false);
</code></pre>
<h2 id="阻止冒泡写法"><a href="#阻止冒泡写法" class="headerlink" title="阻止冒泡写法"></a>阻止冒泡写法</h2><pre><code>event.stopPropagation ? event.stopPropagation() : (event.cancelBubble = true);
</code></pre>
<h2 id="添加事件监听和取消事件监听"><a href="#添加事件监听和取消事件监听" class="headerlink" title="添加事件监听和取消事件监听"></a>添加事件监听和取消事件监听</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加事件监听兼容函数</span><br><span class="line">function addHandler(target, eventType, handler)&#123;</span><br><span class="line">	if(target.addEventListener)&#123;//主流浏览器</span><br><span class="line">		addHandler = function(target, eventType, handler)&#123;</span><br><span class="line">			target.addEventListener(eventType, handler, false);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;else&#123;//IE</span><br><span class="line">		addHandler = function(target, eventType, handler)&#123;</span><br><span class="line">			target.attachEvent(&quot;on&quot;+eventType, handler);</span><br><span class="line">		&#125;;		</span><br><span class="line">	&#125;</span><br><span class="line">	//执行新的函数</span><br><span class="line">	addHandler(target, eventType, handler);</span><br><span class="line">&#125;</span><br><span class="line">//删除事件监听兼容函数</span><br><span class="line">function removeHandler(target, eventType, handler)&#123;</span><br><span class="line">	if(target.removeEventListener)&#123;//主流浏览器</span><br><span class="line">		removeHandler = function(target, eventType, handler)&#123;</span><br><span class="line">			target.removeEventListener(eventType, handler, false);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;else&#123;//IE</span><br><span class="line">		removeHandler = function(target, eventType, handler)&#123;</span><br><span class="line">			target.detachEvent(&quot;on&quot;+eventType, handler);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	//执行新的函数</span><br><span class="line">	removeHandler(target, eventType, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>注：后者皆为兼容IE的兼容性写法。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS尾调用优化</title>
    <url>/2021/12/13/JS%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>上次介绍了什么是尾调用以及怎么准确快速的判别一个函数调用是否为尾调用。那么，我们判别尾调用的意义是什么呢？做什么事情总归有个目的，那么今天我们就来系统的介绍一下尾调用的意义，或者说尾调用有什么用吧。</p>
<h2 id="2-尾调用优化"><a href="#2-尾调用优化" class="headerlink" title="2. 尾调用优化"></a>2. 尾调用优化</h2><p>我们知道，函数的调用会在内存中生成一个“调用帧”（call frame），保存着函数的调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方还会生成一个B的调用帧。等到函数B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B的内部还调用函数C，那么在B的调用帧上方又会生成一个C的调用帧，以此类推。所有的调用帧就形成了一个“调用栈”（call stack）。</p>
<p>我们知道，尾调用是函数的最后一步操作，外部函数的调用位置和其内部变量信息都不会再用到了，所以不需要保留外部函数的调用帧了，直接用内层函数的调用帧取代外层函数的调用帧即可。</p>
<p>如果所有的函数都是尾调用，那么完全可以做到每次执行时的调用帧只有一项，这将大大的节省内存，更不可能发生内存溢出，这就是讨论尾调用的意义所在。</p>
<p>所谓的“尾调用优化”，其实就是保证在函数执行时只保留内层函数的调用帧，换句话说，就是用内层函数的调用帧取代外部函数的调用帧，即执行时内存中只保存一项调用帧。</p>
<h2 id="3-如何做到尾调用优化"><a href="#3-如何做到尾调用优化" class="headerlink" title="3. 如何做到尾调用优化"></a>3. 如何做到尾调用优化</h2><p>通过上面的讨论，我们知道了，只要外部函数的调用帧被内层函数的调用帧取代即可做到“尾调用优化”。同时，我们也知道调用帧是用来保存函数调用位置和内部变量信息的，所以，要想让内层函数的调用帧取代外部函数的调用帧，只需要保证，在调用内层函数时，不再用到和外部函数有关的一切信息即可（不再用到外部函数的内部变量）。</p>
<p>如此，我们总结出只有内层函数在被调用时不再用到外部函数的内部变量，才能做到“尾调用优化”。</p>
<p>先来，看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> n + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子，我们明显可以看出这是典型的尾调用，那么这有没有做到“尾调用优化”呢？很明显，可以看出在调用内部函数g的时候，其内部用到外部函数f 的内部变量b，故在函数g 被调用时，g 的调用帧并不能取代外部函数f 的调用帧，所以这不是“尾调用优化”。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS尾调用</title>
    <url>/2021/12/13/JS%E5%B0%BE%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-尾调用"><a href="#1-尾调用" class="headerlink" title="1. 尾调用"></a>1. 尾调用</h2><p>尾调用（Tail Call）是函数式编程的一个重要的概念，简单的来说就是：某个函数的最后一步是调用另一个函数。</p>
<p>例如下面的例子就是尾调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-尾调用的特点"><a href="#2-尾调用的特点" class="headerlink" title="2. 尾调用的特点"></a>2. 尾调用的特点</h2><p>那么，我们来总结一下，尾调用的特点：</p>
<p>首先，尾调用必须满足，函数的最后一步是return另一个函数（如上述例子），这里和闭包有点像；</p>
<p>其次，return 后面的表达式必须仅仅是某个函数的调用，除此之外不能包含其它任何别的操作；</p>
<p>看下面的例子，我们来分析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a + g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子，就不是尾调用，因为return 后的表达式除了函数调用还包含了加法操作，所以这不是尾调用。</p>
<p>再来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这仍然不是尾调用，因为上述例子相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    g(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，原来的函数并没有return 表达式，相当于返回了undefined，所以此例中的最后一步操作相当于return undefined，所以明显不属于尾调用。</p>
<p>再来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = g(x)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例仍然不属于尾调用，因为最后return 的是函数g(x)的调用返回的结果，所以不是尾调用。</p>
<p>综上所述，判断是不是尾调用，看一看我们总结的那两个条件是否同时满足。</p>
<p>再看一个，你能否判断出下面这个例子是否是尾调用呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> g(x)</span><br><span class="line">    <span class="keyword">return</span> h(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是否是尾调用呢？写下你的答案吧！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组扁平化</title>
    <url>/2021/12/14/JS%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<p>今天看到一个话题讨论JavaScript数组扁平化，忍不住自己也实现一下，在下采用的方式和别人不同，talk is cheap，show you the code!</p>
<h2 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr &amp;&amp; <span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">          </span><br><span class="line">          acc = acc.concat(cur)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> acc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item &amp;&amp; item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(acc)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> acc</span><br><span class="line">        &#125;, [])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三：递归"><a href="#法三：递归" class="headerlink" title="法三：递归"></a>法三：递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      res = res.concat(flatten(arr[i]))</span><br><span class="line">    &#125; <span class="keyword">else</span> res.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四：reduce递归"><a href="#法四：reduce递归" class="headerlink" title="法四：reduce递归"></a>法四：reduce递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">prev, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(val) ? flatten(val) : val)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法五：JSON-stringify-JSON-parse（结合正则替换）"><a href="#法五：JSON-stringify-JSON-parse（结合正则替换）" class="headerlink" title="法五：JSON.stringify / JSON.parse（结合正则替换）"></a>法五：JSON.stringify / JSON.parse（结合正则替换）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(arr)</span><br><span class="line">  str = str.replace(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// console.log(str, 777)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以解决任何多维数组的扁平化，比如，我们实验一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>,<span class="number">11</span>], [<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]],[<span class="number">6</span>,[<span class="number">7</span>, [<span class="number">8</span>,[<span class="number">9</span>]]]]]</span><br><span class="line">   <span class="keyword">let</span> c = flattenArray(arr)</span><br><span class="line">   <span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>

<p>输出，如下：<br><a href="https://img-blog.csdnimg.cn/20190320131543136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190320131543136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>如此，我们就解决了数组扁平化操作。如有不当之处，希望批评指教！在此谢过！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS尾递归优化</title>
    <url>/2021/12/13/JS%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>本文适合对JS基础有较好的理解的基础上阅读体验最佳，若对JS基础没太搞明白的也难会有点晦涩难懂。不知道什么是尾递归的请去看我上一篇对于尾调用的系统讲解。</p>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>函数的递归就是在函数中调用自身，递归在我理解有点像数学中的数学归纳法，数学归纳法的原理在于，不停的利用已知的假设进行推导；而函数的递归同理，不停的调用自身。</p>
<p>先上一个小例子，让大家感受一下递归：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求1 + 2 + 3 + ... + n 的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n + sum(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-递归导致的问题"><a href="#3-递归导致的问题" class="headerlink" title="3. 递归导致的问题"></a>3. 递归导致的问题</h2><p>递归用于解决某些问题，比如深层遍历等问题很有效，但是用不好很容易导致栈溢出错误（stack overflow），就算不发生栈溢出，使用不善则会导致严重的性能问题。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称为“调用帧”（call frame），保存调用位置和内部变量等信息。递归导致的一系列嵌套函数的调用，会产生一系列的调用帧，所有的调用帧就形成了一个“调用栈”（call stack）。调用帧是保存在内存中的，当调用帧足够多的时候，就会出现栈溢出错误。</p>
<p>首先，我们来看看阶乘的递归函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅限非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式和非严格莫是都可用</span></span><br><span class="line"><span class="keyword">var</span>  factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * f(n-<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>递归非常消耗性能，因为需要同时保存成百上千个调用帧，很容易发生栈溢出错误。</p>
<p>像阶乘这样的递归，我们同学们一般会写成像上述这样，那么当我们来计算足够大的数的阶乘时，就会在内存中保存大量的函数调用帧，不但会造成非常差的性能问题，还有可能会出现栈溢出错误。</p>
<p>总结来说，递归有可能导致的问题主要有两个：比较差的性能问题和栈溢出错误。</p>
<h2 id="4-尾递归"><a href="#4-尾递归" class="headerlink" title="4. 尾递归"></a>4. 尾递归</h2><p>什么是尾递归？如果函数尾调用自身就成为尾递归。</p>
<p>上述的例子，显然不属于尾递归，很明显可以看出，return 后面的语句并不只是函数的调用，还有乘法操作，故不属于尾递归。</p>
<p>尾递归可以保证函数执行时内存中始终只保留一个调用帧，这将永远不会发生栈溢出错误，也不会造成差的性能问题。</p>
<p>那么，我们如何对上述的阶乘函数进行优化让其变为尾递归呢？请看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, a1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> a1</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, a1 * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们成功的将阶乘函数通过改造变为了尾递归。</p>
<h2 id="5-如何快速的发现尾递归的思路"><a href="#5-如何快速的发现尾递归的思路" class="headerlink" title="5. 如何快速的发现尾递归的思路"></a>5. 如何快速的发现尾递归的思路</h2><p>记得，笔者在学生阶段学习数学的时候，最喜欢数学中的数学归纳法，笔者作为一名比钢铁还直的理工男在学生阶段最喜欢的学科也是数学。数学归纳法对我的人生产生了很重要的影响，回忆往昔……</p>
<p>扯远了，咱们言归正传，如何快速而又准确的找到尾递归的思路，进而快速而又正确的对递归函数进行尾递归优化。笔者经过科学的推敲和多年反复的验证，发现了一美妙的思路，讲给大家听（笔者是很喜欢分享的）。</p>
<p>首先，我们要找到实现尾递归的思路，我们先把上述的例子前后两个函数拿来对比一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾递归之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何将优化之前的return 之后的表达式变成只有函数的调用而不包含其它额外的操作呢？我们仔细观察第一个函数的return 后的表达式：n * factorial(n-1)，由此可知某一项的计算结果factorial(n)依赖于上一次计算的结果factorial(n-1)，我们最后返回的是factorial(n-1, total * n)，这是一个函数调用的结果，我们就把函数返回的结果记为total，那么不妨在函数factorial加上第二个参数total，即把函数此次调用返回的结果当作第二个参数，那么第一行和第二行就变成了下面这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>难点就在第三行怎么变，接着，我们再来观察第一个函数的return 后面的表达式：n * factorial(n-1)，此时函数factorial已经变了，其拥有两个参数，所以，我们给return后面的调用表达式加上第二个参数，首先第一个参数不变，还是n-1，第二个参数为何是n * total呢？大家想一想factorial(n-1)此次的调用结果是什么呢？举个最简单的例子，当n = 2时，那么大家想想是啥？很容易想到是 2 * 1 = n * total了，所以，优化之后就变成了下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当n = 1，我们1! = 1，所以很容易知道参数中total必须赋值为1时，才是计算正确的阶乘，故将第二个参数的默认参数设为1，这样我们就不用传第二个参数了。</p>
<h2 id="6-实战演练"><a href="#6-实战演练" class="headerlink" title="6. 实战演练"></a>6. 实战演练</h2><p>实战我们来将著名的斐波那契数列进行尾递归优化：</p>
<p>优化之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> getFibo(n-<span class="number">1</span>) + getFibo(n-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这不是尾递归。</p>
<p>开撸，首先结果依赖前两项计算的结果，所以函数需要再额外添加两个参数，这两个参数分别是前两项的计算结果，类比上面的阶乘例子，我们暂且把上一项的计算结果和本次的计算结果分别记为a1和a2，由于本次计算的结果被我们记为了a2，所以当n&lt;=2时，return 后面应该是a2了，即第一行和第二行代码就变为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibo</span>(<span class="params">n, a1, a2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> a2</span><br></pre></td></tr></table></figure>

<p>类比上面的例子，也很容易得到第三行的代码：首先第一个参数 n - 1 不变，因为改变后的函数的第一个参数是n。接下来第二个和第三个参数是我们添加上去的，最简单直接的方法还是令 n = 3，当n = 3 时，上一次结算的结果由第二行代码可知为a2，所以return 后面的函数的第二个参数确定下来了，即为a2，那么当 n = 3 时，本次计算的结果是多少呢，由第一行和第二行代码结合来看，可知当 n = 1 时的上一次计算结果为a1，那么我们可得当 n = 2 时的计算结果为 a2，故return 后面的表达式的第三个参数就为 a1 + a2，所以第三行代码就变成了：</p>
<p><code>return getFibo2(n-1, a2, a1 + a2)</code></p>
<p>至此，整个优化之后的函数就变成了下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibo2</span>(<span class="params">n, a1, a2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> a2</span><br><span class="line">    <span class="keyword">return</span> getFibo2(n-<span class="number">1</span>, a2, a1 + a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带入特殊值验证，当 n = 1 时，可知a1 = 1，当 n = 2 时，a2 = 1；所以完整的计算斐波那契数列的尾递归函数为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibo2</span>(<span class="params">n, a1 = <span class="number">1</span>, a2 = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> a2</span><br><span class="line">    <span class="keyword">return</span> getFibo2(n-<span class="number">1</span>, a2, a1 + a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经讲完了，你get到尾递归以及如何进行尾递归函数的编写了吗？</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS检测属性位于对象本身还是来自于其原型链</title>
    <url>/2021/12/13/JS%E6%A3%80%E6%B5%8B%E5%B1%9E%E6%80%A7%E4%BD%8D%E4%BA%8E%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%E8%BF%98%E6%98%AF%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%85%B6%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="1-in-操作符"><a href="#1-in-操作符" class="headerlink" title="1.in 操作符"></a>1.in 操作符</h2><p>in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于对象本身还是其原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Person.prototype.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">   Person.prototype.code = <span class="number">23</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj) <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;code&#x27;</span> <span class="keyword">in</span> obj) <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;gender&#x27;</span> <span class="keyword">in</span> obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h2 id="2-obj-hasOwnProperty-prop"><a href="#2-obj-hasOwnProperty-prop" class="headerlink" title="2.obj.hasOwnProperty(prop)"></a>2.obj.hasOwnProperty(prop)</h2><p>hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   Person.prototype.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">   Person.prototype.code = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;code&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="3-两者结合判断属性位于对象本身还是来自于其原型链"><a href="#3-两者结合判断属性位于对象本身还是来自于其原型链" class="headerlink" title="3.两者结合判断属性位于对象本身还是来自于其原型链"></a>3.两者结合判断属性位于对象本身还是来自于其原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   Person.prototype.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">   Person.prototype.code = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">propertyFormPrototype</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> !obj.hasOwnProperty(prop) &amp;&amp; prop <span class="keyword">in</span> obj</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(propertyFormPrototype(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">   <span class="built_in">console</span>.log(propertyFormPrototype(obj, <span class="string">&#x27;code&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS滚动加载</title>
    <url>/2021/12/25/JS%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期比较忙，有几个大项目，一直忙到昏天暗地，都没时间更新博客，今天终于有时间啦，上正题，今天我们来聊一聊JS的滚动加载。在日常需求中，无数次的会遇到滚动加载的相关需求。</p>
<p>今天，我们呢用原生JS实现滚动加载，我相信原生JS都能实现，使用vue、react等前端框架实现那更不是问题，话不多说，先大致描述一下我们要实现的功能（描述需求，一个好的产品经理是多么的重要）：有一堆要展示的内容，但是我们不一次性展示出来，初始先展示一屏幕高度的内容，当滚动到页面底部时，这个时候一般是去请求接口拿数据，进而展示出来，但是今天，我们就不请求接口了，我们用添加dom元素来替代之。</p>
<p>先摆出页面的静态结构如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blank</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.lazy</span> &#123;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">display</span>: none;</span><br><span class="line">	<span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>11<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>12<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>13<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>14<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>15<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>16<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>17<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>18<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>19<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>20<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>21<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;blank&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span>懒加载中...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>好了，需求描述完毕，下面开始分析：如何知道页面是否已经滚动到底部？这是这个需求的核心部分。</p>
<h2 id="一、第一种方式"><a href="#一、第一种方式" class="headerlink" title="一、第一种方式"></a>一、第一种方式</h2><p>有的同学会想到监听scroll事件，然后判断有滚动内容的元素的scrollTop值加上此元素的高度值（clientHeight），然后拿这个计算出来的值与此元素的scrollHeight值进行比较，一般取差值，看是否在某个误差范围内（这个范围一般来说是很小的值），若在范围内，则取请求接口，拿数据，进而展示。</p>
<p>上述这是一般的实现方式，那么，我们来以第一种思路来实现一下：</p>
<p>scrollTop、scrollHeight与clientHeight的重要关系：<br>关系公式：element.scrollHeight - element.scrollTop === element.clientHeight</p>
<p>解释：此公式可以用于判断是否滚动到底。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> ul = app.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> blank = app.querySelector(<span class="string">&#x27;.blank&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> lazyDom = app.querySelector(<span class="string">&#x27;.lazy&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="built_in">console</span>.log(fragment, <span class="number">99</span>);</span><br><span class="line">    <span class="keyword">const</span> maxNum = +ul.querySelector(<span class="string">&#x27;li:last-of-type&#x27;</span>).innerText;</span><br><span class="line">    <span class="built_in">console</span>.log(maxNum + NUM, <span class="number">777</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = maxNum; index &lt; maxNum + NUM;) &#123;</span><br><span class="line">      <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">      dom.innerText = ++index;</span><br><span class="line">      fragment.appendChild(dom);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span>, context = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(context);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(app.scrollTop + app.clientHeight - app.scrollHeight) &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">      lazyDom.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createDom();</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.scrollTop == <span class="number">0</span>) &#123;</span><br><span class="line">      lazyDom.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(fn, <span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="二、第二种方式"><a href="#二、第二种方式" class="headerlink" title="二、第二种方式"></a>二、第二种方式</h2><p>第二种方式是监听底部元素<p class="blank"></p>是否进入视口，由于此元素在最底部，而且高度设置了1px，所以基本不影响布局，若此元素进入视口，则说明已经滚动到了最底部。OK，来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) &#123;</span><br><span class="line">    lazyDom.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      createDom();</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lazyDom.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.observe(blank);</span><br></pre></td></tr></table></figure>
<p>那么接下来，请允许我简单的介绍一下一个非常重要的API：IntersectionObserver。</p>
<p><strong>IntersectionObserver</strong>接口 (从属于<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" title="Intersection Observer API">Intersection Observer API</a>) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p>
<p>当一个<strong>IntersectionObserver</strong>对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p>
<p>上述是MDN官方的解释说明。我们通俗一点来讲，其实此API就是可以判断被监听的元素是否出现或者消失在视口，通过isIntersecting属性的值（true、false）来判断是否在视口。当被监听的元素由在视口不可见变成在视口可见的那一瞬间，此属性由false变为true；当被监听的元素由在视口可见变成在视口不可见的那一瞬间，此属性由true变为false。</p>
<p>要注意的是，只有当被监听的元素出现或消失在视口的那一瞬间，回调函数才会执行。若被监听的元素一直在视口种，则回调函数不会执行，同理，一直消失的话回调函数也不会执行。</p>
<p>以上两种方式就是实现滚动加载的方案，个人比较倾向于第二种，比较简单，代码量也较少，而且性能开销也不大。</p>
<p>本文纯属个人观点，若有不正确之处，望大家不吝赐教。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>JS趣事：监听浏览器tab页切换</title>
    <url>/2021/12/31/JS%E8%B6%A3%E4%BA%8B%EF%BC%9A%E7%9B%91%E5%90%AC%E6%B5%8F%E8%A7%88%E5%99%A8tab%E9%A1%B5%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>书中自有黄金屋，书中自有颜如玉！今天看书看到一个好玩的东西，随即想用博客记录一下，也想分享给更多的技术猿知道。那就是当我们切换浏览器的tab页的时候，可以对此行为进行监听，然后做一些自己想做的事情，比如改一改页面title了，或者别的一些操作。</p>
<h2 id="JS监听浏览器tab页切换"><a href="#JS监听浏览器tab页切换" class="headerlink" title="JS监听浏览器tab页切换"></a>JS监听浏览器tab页切换</h2><p>浏览器标签页被隐藏或显示的时候会触发 visibilitychange 事件。直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.hidden !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.hidden)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们离开当前tab页的时候，控制台输出true，当我们进入当前tab页的时候，控制台输出false。</p>
<p>那我们利用这一特性来做一个简单的小案例，我们在用户由当前tab页切换到其他tab页的时候，我们修改当前tab页面的标题用来提醒用户快回来当前tab页，当用户再次回来的时候，我们再把页面title正常显示为原来的页面标题，show code：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TITLE = <span class="built_in">document</span>.title</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.hidden !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">777</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.title = <span class="string">&quot;看啥呢,快回来啊~~&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.title = TITLE</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS生成随机颜色值</title>
    <url>/2021/12/13/JS%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2%E5%80%BC/</url>
    <content><![CDATA[<h2 id="1-rgb-颜色值"><a href="#1-rgb-颜色值" class="headerlink" title="1.rgb()颜色值"></a>1.rgb()颜色值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgbColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> rgb = <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>;</span><br><span class="line">        <span class="keyword">return</span> rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-rgba-颜色值"><a href="#2-rgba-颜色值" class="headerlink" title="2.rgba()颜色值"></a>2.rgba()颜色值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgbaColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">let</span> a = <span class="built_in">Math</span>.random().toFixed(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> rgba = <span class="string">`rgba(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;a&#125;</span>)`</span>;</span><br><span class="line">        <span class="keyword">return</span> rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-16进制颜色值"><a href="#3-16进制颜色值" class="headerlink" title="3.16进制颜色值"></a>3.16进制颜色值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color16</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> color = <span class="string">&#x27;#&#x27;</span>+r.toString(<span class="number">16</span>)+g.toString(<span class="number">16</span>)+b.toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-数组拼接法"><a href="#4-数组拼接法" class="headerlink" title="4.数组拼接法"></a>4.数组拼接法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorArr=[<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">min,max</span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">if</span>(<span class="built_in">isNaN</span>(min) || <span class="built_in">isNaN</span>(max))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span>(min &gt; max)&#123;</span><br><span class="line">		min ^= max;</span><br><span class="line">		max ^= min;</span><br><span class="line">		min ^= max;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> (<span class="built_in">Math</span>.random() * (max - min) | <span class="number">0</span>) + min;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">arrColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">var</span> color=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">	    color += colorArr[random(<span class="number">0</span>,<span class="number">16</span>)];</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-随机数生产法"><a href="#5-随机数生产法" class="headerlink" title="5.随机数生产法"></a>5.随机数生产法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNumColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> color=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">          color += (<span class="built_in">Math</span>.random()*<span class="number">16</span> | <span class="number">0</span>).toString(<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-16进制随机数生成法"><a href="#6-16进制随机数生成法" class="headerlink" title="6.16进制随机数生成法"></a>6.16进制随机数生成法</h2>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>+ (<span class="built_in">Math</span>.random() * <span class="number">0x1000000</span> | <span class="number">0</span>).toString(<span class="number">16</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS闭包巧用</title>
    <url>/2021/12/13/JS%E9%97%AD%E5%8C%85%E5%B7%A7%E7%94%A8/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>什么是闭包？闭包有什么作用？这是我遇到闭包时的第一反应。</p>
<p>闭包在JavaScript高级程序设计（第3版）中是这样描述：闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>那么闭包的作用也就很明显了：</p>
<ol>
<li>可以在函数的外部访问到函数内部的局部变量。</li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ol>
<h2 id="1-让函数只执行一次"><a href="#1-让函数只执行一次" class="headerlink" title="1.让函数只执行一次"></a>1.让函数只执行一次</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">          fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">12306</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> c = once(log)</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br></pre></td></tr></table></figure>
<p>上述代码只输出一次12306，利用闭包达到了让函数只执行一次的效果。</p>
<h2 id="2-函数柯里化"><a href="#2-函数柯里化" class="headerlink" title="2. 函数柯里化"></a>2. 函数柯里化</h2><p>函数柯里化有以下几种版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> _args = [...arguments]</span><br><span class="line">      <span class="keyword">if</span> (args !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        _args = [...args, ..._args]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_args.length &lt; fn.length) &#123;</span><br><span class="line">        curry(fn, _args)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn.apply(<span class="literal">null</span>, _args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arg1 = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length - <span class="built_in">arguments</span>.length &lt;= arg1.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = [...arg1, ...arguments]</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> curried(...arguments, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始不传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length == fn.length) <span class="keyword">return</span> fn(...args)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后要加一次额外的调用版本()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arg1 = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length - <span class="built_in">arguments</span>.length &lt;= arg1.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = [...arg1, ...arguments]</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> fn2(...arguments, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数节流"><a href="#3-函数节流" class="headerlink" title="3. 函数节流"></a>3. 函数节流</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, ctx = <span class="literal">null</span>, duration = <span class="number">2000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="number">0</span>, first = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> endTime = <span class="built_in">Date</span>.now()</span><br><span class="line">      <span class="keyword">if</span> (endTime - startTime &gt;= duration) &#123;</span><br><span class="line">        fn.apply(ctx, <span class="built_in">arguments</span>)</span><br><span class="line">        startTime = endTime</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.type, <span class="number">777</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cd = throttle(fn)</span><br><span class="line">  <span class="built_in">window</span>.onscroll = cd</span><br></pre></td></tr></table></figure>
<h2 id="4-函数防抖"><a href="#4-函数防抖" class="headerlink" title="4. 函数防抖"></a>4. 函数防抖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, ctx = <span class="literal">null</span>, delay = <span class="number">2000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(ctx, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.type, <span class="number">3333</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cc = debounce(fn)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.onresize = cc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript冒泡排序</title>
    <url>/2021/12/14/JavaScript%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>冒泡排序</strong>（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>冒泡排序之所以叫冒泡排序，是因为使用这种算法进行排序时，数据值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值会浮动到数组的左侧。之所以产生这种现象是因为算法会多次在数组中移动，比较相邻的数据，而左侧值大于右侧值时将它们进行互换。</p>
<h2 id="算法实现逻辑"><a href="#算法实现逻辑" class="headerlink" title="算法实现逻辑"></a>算法实现逻辑</h2><p>冒泡排序算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="JavaScript代码实现冒泡排序"><a href="#JavaScript代码实现冒泡排序" class="headerlink" title="JavaScript代码实现冒泡排序"></a>JavaScript代码实现冒泡排序</h2><h3 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">      arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写法二："><a href="#写法二：" class="headerlink" title="写法二："></a>写法二：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 一行代码实现两变量互换</span></span><br><span class="line">      [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型之对象属性设置与屏蔽</title>
    <url>/2022/01/01/JavaScript%E5%8E%9F%E5%9E%8B%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%B1%8F%E8%94%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript和面向类的语言不同，在ES6出现之前，它其实并没有类来作为对象的抽象模式，所以在描述对象中不免会遇到一个特别的词语，没错就是原型prototype，今天我们讨论的主角也是它，今天我们就来讨论JavaScript原型中的冰山一角。</p>
<h2 id="三道面试题"><a href="#三道面试题" class="headerlink" title="三道面试题"></a>三道面试题</h2><p>让我们先来看三道面试题，慢慢的打开你的视野：<br>先列出三道题目都会用到的对象objProto：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objProto = &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目一</span></span><br><span class="line">objProto.a = <span class="number">23</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(objProto)</span><br><span class="line">obj.a = <span class="number">24</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目二</span></span><br><span class="line"><span class="comment">// 设置objProto对象的a属性为只读属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProto, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  	<span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">value</span>: <span class="number">23</span>,</span><br><span class="line">	<span class="attr">writeable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(objProto)</span><br><span class="line">obj.a = <span class="number">24</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目三</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objProto, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  	<span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;对象objProto的a属性被设置了！&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(objProto)</span><br><span class="line">obj.a = <span class="number">24</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>那么你知道上述三道题的答案吗？<br>让我们来一一进行分析吧：</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>对于第一道题，这是我们大多数人都知道并且了解的场景，答案也很明显，没错就是控制台会打印24和true，那么我们再来看看题目一中的对象obj长啥样，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/8fe4e2c4b16d448eb2634942a9f42397.png#pic_center" alt="在这里插入图片描述"><br>通过上图我们不难看出，对象a被加在了obj对象的自身属性上了，其原型上的属性a还是原来的23，有没有人会以为改变的是原型上的a属性的值呢？我想还是会有人这样认为的吧。那么为什么a属性被加在obj自身上而不是改变其原型上的a属性呢，obj对象自身原本是不存在a的啊。原因我们待会儿再来解释，我们不妨先来看后面两道题目。</p>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>对于题目二，你的答案又是什么呢？<br>好吧，先让我来告诉你答案吧，控制台会打印出23和false，哈哈，是不是出乎你的意料呢？那我们再来看看obj对象长啥样吧，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/9f94dd831d864cb895386fbc008f2b3e.png#pic_center" alt="在这里插入图片描述"><br>what fuck？obj对象里面空空如也，为什么，我明明对obj对象的a属性进行赋值操作了啊 <code>obj.a = 24</code> ，既然都进行赋值操作了，那为什么obj对象还空空如也呢，先保留着你的疑问，让我们先来看第三道题目。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>题目三的答案你想到了吗？好了，不卖关子了，直接说了，题目三的控制台会打印23和false，同上我们先来看看obj对象长啥样，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/2a76b8f2391a43b8b232eb15482951b1.png#pic_center" alt="在这里插入图片描述"><br>what fuck？obj.hasOwnProperty(‘a’)不是false吗？为什么控制台打印obj对象，还能看到其自身属性也有a属性？what fuck？这到底是怎么一回事呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们先来总结一下：<br>对于对象自身不含有的属性而其原型对象含有的属性，当我们设置此属性时的几种情况：</p>
<ol>
<li>如果原型对象objProto的此属性并没有被标记为只读属性，那么会直接在obj对象自身属性上创建该属性为一个新属性，这就是<strong>屏蔽属性</strong>。</li>
<li>如果原型对象objProto的此属性被标记为只读属性，那么无法修改原型的此属性值也无法在对象obj自身上创建该属性，也就是此情况下不会发生<strong>屏蔽属性</strong>。如果是严格模式下， <code>obj.a = 24</code>  这行代码会报错，否则赋值语句 <code>obj.a = 24</code>  会被忽略，总之不会发生屏蔽。</li>
<li>如果原型对象objProto的此属性，并且有setter，那就一定会调用这个setter。根据 obj.hasOwnProperty(‘a’) 的值为false，我们可以得知该属性并不会被添加到obj自身上（可是我们在控制台打印obj又会看到obj自身属性中含有a，对于三，笔者我也没想明白咋回事，明明hasOwnProperty为false，但是又看到了其自身属性确实有a属性的存在，语言bug？）</li>
</ol>
<p>第一种情况是我们日常开发中遇到的大多数情况，二和三很少遇到，尤其是三，着实让人摸不着头脑，也难怪有很多大神说JavaScript是一门像屎一样的语言，无可厚非，毕竟JavaScript是在短短十天内就被创造出来的，就像我们日常开发一样，时间短速度快那代码自然bug就多呗。虽然JavaScript在某些方面很垃圾，但是其足够的灵活性也让人爱不释手。</p>
<p>好了，今天就聊到这里，有谁知道三是怎么回事的，欢迎给笔者留言。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript函数传参---按值传递</title>
    <url>/2021/12/19/JavaScript%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>所有函数的参数都是按值传递的,也就是说把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。所以如果能理解变量的复制，那么参数的传递也就很简单了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.name = <span class="string">&#x27;Toney&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;name: &quot;Toney&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

<p>总所周知，在JavaScript中，引用数据类型存储在堆中，传递时传递的实际上是指向此地址的一个指针，如上例，obj作为参数被传递到了函数内部，实际上相当于复制了一个指针，而指针指向的地址还是此对象所对应的地址，所以改变了函数的参数属性，实际上相当于操作obj的属性改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;name: &quot;Tom&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

<p>如上，当对参数arr再次赋值时，此时这个指针指向的地址就发生了改变，指向了所赋值的新对象{}，从而与obj无关了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript希尔排序</title>
    <url>/2021/12/18/JavaScript%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>希尔排序</strong>（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<h2 id="算法实现逻辑"><a href="#算法实现逻辑" class="headerlink" title="算法实现逻辑"></a>算法实现逻辑</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<h2 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h2><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p>
<p>Donald Shell最初建议步长选择为<code>n/2</code>并且对步长取半直到步长达到1。虽然这样取可以比<code>O(n^2)</code>类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。</p>
<h2 id="JavaScript代码实现希尔排序"><a href="#JavaScript代码实现希尔排序" class="headerlink" title="JavaScript代码实现希尔排序"></a>JavaScript代码实现希尔排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length</span><br><span class="line">  <span class="keyword">let</span> gap = len / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> outer = gap; outer &lt; len; outer++) &#123;</span><br><span class="line">      <span class="keyword">const</span> TEMP = list[outer]</span><br><span class="line">      <span class="keyword">let</span> inner = outer</span><br><span class="line">      <span class="keyword">while</span> (inner - gap &gt;= <span class="number">0</span> &amp;&amp; list[inner - gap] &gt; TEMP) &#123;</span><br><span class="line">        list[inner] = list[inner - gap]</span><br><span class="line">        inner -= gap</span><br><span class="line">      &#125;</span><br><span class="line">      list[inner] = TEMP</span><br><span class="line">    &#125;</span><br><span class="line">    gap = gap / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript归并排序</title>
    <url>/2021/12/18/JavaScript%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>归并排序</strong>（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h2 id="算法逻辑思想"><a href="#算法逻辑思想" class="headerlink" title="算法逻辑思想"></a>算法逻辑思想</h2><h3 id="采用分治法"><a href="#采用分治法" class="headerlink" title="采用分治法:"></a>采用分治法:</h3><ol>
<li>分割：递归地把当前序列平均分割成两半。</li>
<li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li>
</ol>
<h3 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h3><p><strong>归并操作</strong>（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<h4 id="递归法（Top-down）"><a href="#递归法（Top-down）" class="headerlink" title="递归法（Top-down）"></a>递归法（Top-down）</h4><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>原理如下（假设序列共有 n 个元素）：</p>
<ol>
<li>将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ol>
<h2 id="JavaScript代码实现归并排序"><a href="#JavaScript代码实现归并排序" class="headerlink" title="JavaScript代码实现归并排序"></a>JavaScript代码实现归并排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rec = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">const</span> mid = arr.length &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">    <span class="keyword">const</span> right = arr.slice(mid)</span><br><span class="line">    <span class="keyword">const</span> arr1 = rec(left)</span><br><span class="line">    <span class="keyword">const</span> arr2 = rec(right)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">        res.push(arr1[i++])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push(arr2[j++])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; arr1.length) res = res.concat(arr1.slice(i))</span><br><span class="line">    <span class="keyword">if</span> (j &lt; arr2.length) res = res.concat(arr2.slice(j))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rec(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript快速排序</title>
    <url>/2021/12/18/JavaScript%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 (nlogn) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<h2 id="算法逻辑思想"><a href="#算法逻辑思想" class="headerlink" title="算法逻辑思想"></a>算法逻辑思想</h2><p>快速排序使用<strong>分治法</strong>（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>步骤为：</p>
<ol>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ol>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p>
<h2 id="JavaScript代码实现快速排序"><a href="#JavaScript代码实现快速排序" class="headerlink" title="JavaScript代码实现快速排序"></a>JavaScript代码实现快速排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rec = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">const</span> left = []</span><br><span class="line">    <span class="keyword">const</span> right = []</span><br><span class="line">    <span class="keyword">const</span> mid = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">        left.push(arr[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...rec(left), mid, ...rec(right)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rec(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript手写new操作符</title>
    <url>/2021/12/24/JavaScript%E6%89%8B%E5%86%99new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要实现new操作符，首先得知道new操作符干了哪些事情：</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>第一、new操作符会创建一个对象并返回，且此对象的<code>__proto__</code>等于此函数的原型<code>prototype</code>（这里需要注意<code>__proto__</code>和<code>prototype</code>的区别和联系，原型<code>prototype</code>是函数才有的，务必记住，而<code>__proto__</code>可以理解为对象的某个属性，此属性指向对象的构造函数的prototype，是不是很绕。举个例子）；<br>比如，new函数A创建了对象a，则<code>a.__proto__ =  A.prototype</code>，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === A.prototype)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>第二、函数体中的this指向new操作符所创建的对象；</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>第三、如果此函数的返回值为对象，则函数的返回值则为函数体中所写的返回值，否则new操作符则创建一个对象并返回；<br>弄清楚了这三件事，下面就可以入手开始实现自己的new了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">  <span class="keyword">const</span> res = fn.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有更好的写法，欢迎指出。</p>
]]></content>
      <categories>
        <category>手写代码</category>
      </categories>
      <tags>
        <tag>手写代码</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript插入排序</title>
    <url>/2021/12/18/JavaScript%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="算法实现逻辑"><a href="#算法实现逻辑" class="headerlink" title="算法实现逻辑"></a>算法实现逻辑</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5；</li>
</ol>
<h2 id="JavaScript代码实现插入排序"><a href="#JavaScript代码实现插入排序" class="headerlink" title="JavaScript代码实现插入排序"></a>JavaScript代码实现插入排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len  = list.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> outer = <span class="number">1</span>; outer &lt; len; outer++) &#123;</span><br><span class="line">    <span class="keyword">const</span> TEMP = list[outer]</span><br><span class="line">    <span class="keyword">let</span> inner = outer</span><br><span class="line">    <span class="keyword">while</span> (inner &gt; <span class="number">0</span> &amp;&amp; list[inner - <span class="number">1</span>] &gt; TEMP) &#123;</span><br><span class="line">      list[inner] = list[inner - <span class="number">1</span>]</span><br><span class="line">      inner--</span><br><span class="line">    &#125;</span><br><span class="line">    list[inner] = TEMP</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法动画"><a href="#算法动画" class="headerlink" title="算法动画"></a>算法动画</h2><p>插入排序的动画如下所示：<br><a href="https://img-blog.csdnimg.cn/20190407185906854.gif"><img src="https://img-blog.csdnimg.cn/20190407185906854.gif"></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript正则表达式精华总结</title>
    <url>/2021/12/25/JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p>
<p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p>
<p>正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本文，加上应用的时候进行一定的参考，掌握正则表达式不是问题。</p>
<h2 id="创建正则表达式的两种方式"><a href="#创建正则表达式的两种方式" class="headerlink" title="创建正则表达式的两种方式"></a>创建正则表达式的两种方式</h2><h3 id="1-字面量方式"><a href="#1-字面量方式" class="headerlink" title="1. 字面量方式"></a>1. 字面量方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d/g</span></span><br></pre></td></tr></table></figure>

<p>如上代码所示，即是字面量方式创建正则表达式。</p>
<h3 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2. 构造函数方式"></a>2. 构造函数方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>RegExp 为创建正则表达式的构造函数，有两个参数，第二个参数不是必传的。第一个参数是一个字符串，指定了正则表达式的模式或其他正则表达式，第二个参数是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果第一个参数是正则表达式，而不是字符串，则必须省略该参数。</p>
<p>返回值为一个新的 RegExp 对象，具有指定的模式和标志。如果第一个参数是正则表达式而不是字符串，那么 RegExp() 构造函数将用与指定的 RegExp 相同的模式和标志创建一个新的 RegExp 对象。</p>
<p>如果不用 new 运算符，而将 RegExp() 作为函数调用，那么它的行为与用 new 运算符调用时一样，只是当第一个参数是正则表达式时，它只返回第一个参数，而不再创建一个新的 RegExp 对象。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.&#124;\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或′’。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y&#124;ies) 就是一个比 ‘industry&#124;industries’ 更简略的表达式。</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95&#124;98&#124;NT&#124;2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95&#124;98&#124;NT&#124;2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?&lt;=pattern)</td>
<td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95&#124;98&#124;NT&#124;2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95&#124;98&#124;NT&#124;2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。</td>
</tr>
<tr>
<td>x&#124;y</td>
<td>匹配 x 或 y。例如，’z&#124;food’ 能匹配 “z” 或 “food”。’(z&#124;f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
</tr>
<tr>
<td>\nml</td>
<td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
</tr>
</tbody></table>
<h2 id="正则的捕获exec"><a href="#正则的捕获exec" class="headerlink" title="正则的捕获exec"></a>正则的捕获exec</h2><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">RegExpObject.exec(string)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。要检索的字符串。</td>
</tr>
</tbody></table>
<p>返回值：返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h3 id="（1）懒惰性"><a href="#（1）懒惰性" class="headerlink" title="（1）懒惰性"></a>（1）懒惰性</h3><p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure>
<p>上述三个打印输出的都是一样的：<br><a href="https://img-blog.csdnimg.cn/2019051311074580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/2019051311074580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>我们可以发现，每次匹配到的结果都是相同的，而且索引index的值一直没变，始终指向第一次匹配到的字符串的起始位置，这就是正则的<strong>懒惰性</strong>，只匹配第一次匹配到的结果，不再向后匹配。</p>
<p>怎么解决懒惰性问题呢？很容易，加个全局修饰符即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure>
<p>如上，我们加上全局修饰符之后，再来看输出结果：<br><a href="https://img-blog.csdnimg.cn/20190513111421282.png"><img src="https://img-blog.csdnimg.cn/20190513111421282.png"></a></p>
<p>我们可以看到，112，456，789这三个数字在原始字符串中都被捕获到了，并且每次的index值也发生了变化；第四个输出为null，表示捕获结束，后面再没有可以捕获的内容了。如此就解决了正则的懒惰性问题。</p>
<h3 id="（2）贪婪性"><a href="#（2）贪婪性" class="headerlink" title="（2）贪婪性"></a>（2）贪婪性</h3><p>还是以上述例子来讲：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果，我们现在想单独捕获到每一个数字，即1，1，2，4，5，6，7，8，9，此时该怎么办呢？</p>
<p>若像上述例子中那样捕获到，则捕获到的内容是数字112，456，789，这三个三位数，显然这把满足要求的连续数字都给一次性捕获到了，这其实就是正则的贪婪性。</p>
<p>那么，如何解决正则的贪婪性呢？即，我们要单独获取到1，1，2，4，5，6，7，8，9这些单个数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+?/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure>
<p>解决贪婪性也很简单，即在+后面加一个问号（？）即可。</p>
<p>我们来看加了问号之后的输出：<br><a href="https://img-blog.csdnimg.cn/20190513113709574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190513113709574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>解决正则的贪婪性很简单，即在量词元字符的后面加问号（？）即可，此例中的量词元字符为+。</p>
<h2 id="正则捕获（字符串的match方法）"><a href="#正则捕获（字符串的match方法）" class="headerlink" title="正则捕获（字符串的match方法）"></a>正则捕获（字符串的match方法）</h2><p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<p>该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringObject.match(searchvalue)</span><br><span class="line">stringObject.match(regexp)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>searchvalue</td>
<td>必需。规定要检索的字符串值。</td>
</tr>
<tr>
<td>regexp</td>
<td>必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</td>
</tr>
</tbody></table>
<p>返回值存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p>
<p>match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。</p>
<p>如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。</p>
<p>如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。</p>
<p>注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.exec()。</p>
<p>还是以上述的例子来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513115053752.png"><img src="https://img-blog.csdnimg.cn/20190513115053752.png"></a></p>
<p>可以看到，一次性把满足条件的内容全部都给捕获到了，然后放在了一个数组中。</p>
<p>再来看，消除贪婪性后的match方法捕获的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+?/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;112hello456world789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513115256928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190513115256928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>可以看到，满足条件的内容都捕获到了。</p>
<h3 id="match的缺点"><a href="#match的缺点" class="headerlink" title="match的缺点"></a>match的缺点</h3><p>match方法虽然很好用，但是在分组捕获中满足子表达式的内容，使用match方法是无法捕获到的。继续往下看分组捕获时会仔细讲解match。</p>
<h2 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h2><p>我们已经知道直接在字符后面加上限定符就可以重复单个字符，那么多个字符的重复又该如何实现呢？你可以使用小括号来指定子表达式（也称为分组），然后对于这个子表达式的重复次数你就可以自行规定了，子表达式也可以进行一些其他的操作，这个在后面会进行介绍。</p>
<h3 id="（1）改变优先级"><a href="#（1）改变优先级" class="headerlink" title="（1）改变优先级"></a>（1）改变优先级</h3><p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^15|16$/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;15&quot;</span>));  </span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;16&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;159&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;1569&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;216&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;6216&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;326&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513140908536.png"><img src="https://img-blog.csdnimg.cn/20190513140908536.png"></a></p>
<p>很显然，以15开头或者以16结尾的所有字符串都符合条件。那如果我们的原意是想匹配156或116呢？此时只需要加个小括号进行分组即可，修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^1(5|1)6$/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;15&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;16&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;159&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;1569&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;216&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;6216&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;326&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;116&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;156&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513141226828.png"><img src="https://img-blog.csdnimg.cn/20190513141226828.png"></a></p>
<p>很显然此时只匹配156或116了。加了小括号之后改变了|元字符的作用范围。</p>
<h3 id="（2）后向引用"><a href="#（2）后向引用" class="headerlink" title="（2）后向引用"></a>（2）后向引用</h3><p>假设现在我们想匹配一个字符串中连续重复的字符该怎么办呢？此时，我们便可以利用正则表达式分组中的后向引用。</p>
<p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<p>那么，对于想要匹配一个字符串中连续重复的字符，我们可以利用后向引用来解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\w)\1+/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ppfhhhdfhdddskkk96fff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513143008628.png"><img src="https://img-blog.csdnimg.cn/20190513143008628.png"></a></p>
<p>其中 reg 中的 \1 是对前面第一个小括号里面匹配到的内容的引用，于是就解决重复的问题。</p>
<p>例如， /(a)(b)\1\2/可以匹配”abab”，其中 \1,\2分别是对第一个小括号（第一个分组）和第二个小括号（第二个分组）里面匹配到的内容的引用。</p>
<p>需要注意的是，如果引用了越界或者不存在的编号的话，就被被解析为普通的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w&#123;3&#125;) is \6/</span>;</span><br><span class="line">reg.test( <span class="string">&#x27;kid is kid&#x27;</span> ); <span class="comment">// false</span></span><br><span class="line">reg.test( <span class="string">&#x27;kid is \6&#x27;</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="（3）非捕获型分组"><a href="#（3）非捕获型分组" class="headerlink" title="（3）非捕获型分组"></a>（3）非捕获型分组</h3><p>使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>
<p>在一个分组中最开头使用？开头，则此分组为非捕获型分组，即此分组匹配结果不会被缓存，使用exec也不会捕获到此分组内的内容，此分组不存在分组序号，即此分组不存在 \n ，也就是说不存在后向引用的操作。</p>
<p>正向前瞻型分组：你站在原地往前看，如果前方是指定的东西就返回true，否则为false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/kid is a (?=doubi)/</span></span><br><span class="line">reg.test(<span class="string">&#x27;kid is a doubi&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">reg.test(<span class="string">&#x27;kid is a shabi&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>反向前瞻型分组：你站在原地往前看，如果前方不是指定的东西则返回true，如果是则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/kid is a (?!doubi)/</span></span><br><span class="line">reg.test(<span class="string">&#x27;kid is a doubi&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">reg.test(<span class="string">&#x27;kid is a shabi&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>假如现在有这样一个需求，将一个数字字符串每三位中间以逗号分隔，例如，123456789变为123,456,789这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;36545454551&#x27;</span></span><br><span class="line"></span><br><span class="line">str = str.replace(reg, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str);    <span class="comment">// 36,545,454,551</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串replace方法"><a href="#字符串replace方法" class="headerlink" title="字符串replace方法"></a>字符串replace方法</h2><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringObject.replace(regexp/substr,replacement)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>regexp/substr</td>
<td>必需。规定子字符串或要替换的模式的 RegExp 对象。</td>
</tr>
</tbody></table>
<p>请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</p>
<p>replacement    必需。一个字符串值。规定了替换文本或生成替换文本的函数。<br>返回值为一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p>
<p>当第一个参数为字符串时，每次替换只会替换第一次匹配到的字符串，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ggghhhggg&#x27;</span></span><br><span class="line">str = str.replace(<span class="string">&#x27;ggg&#x27;</span>, <span class="string">&#x27;kkk&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str);   <span class="comment">// kkkhhhggg</span></span><br></pre></td></tr></table></figure>

<p>那若是我们想要替换掉所有匹配到的内容呢？此时第一个参数则需要传入一个正则表达式，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ggghhhggg&#x27;</span></span><br><span class="line">str = str.replace(<span class="regexp">/g&#123;3&#125;/g</span>, <span class="string">&#x27;kkk&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str);   <span class="comment">// kkkhhhkkk</span></span><br></pre></td></tr></table></figure>
<p>第二个参数除了传字符串之外，还可以传入一个函数，我们来看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ggg123hhh456ggg78&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d)&#123;3&#125;/g</span></span><br><span class="line">str = str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513164857738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190513164857738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>可见输出了两次，分为为匹配到的123和456。</p>
<p>我们使用exec和match分别来匹配试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ggg123hhh456ggg78&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d)&#123;3&#125;/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190513170018314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190513170018314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>再来看看match的结果：<br><a href="https://img-blog.csdnimg.cn/20190513170125678.png"><img src="https://img-blog.csdnimg.cn/20190513170125678.png"></a></p>
<p>综上所述，我们不难看出 replace 函数的第二个参数为函数时，此匿名函数的参数为 replace 函数的第一个参数的正则表达式对原始字符串每次执行 exec 后的结果。</p>
<p>此时，也可以点出match函数虽然可以直接得到符合条件的数组，这一点非常好用，毋庸置疑。但是 match 函数的的不足之处在于，它无法捕获到分组中的小正则表达式匹配的内容，如此例中的（\d）匹配到的内容，match 方法无法捕获到，但是小正则中匹配到的内容，exec 函数却可以捕获到。</p>
<p>假如此例中，我们需要把连续三个数字替换为666，则我们可以利用 replace 函数这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ggg123hhh456ggg78&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d)&#123;3&#125;/g</span></span><br><span class="line"></span><br><span class="line">str = str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;666&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str);    <span class="comment">// ggg666hhh666ggg78</span></span><br></pre></td></tr></table></figure>

<p>replace 函数每次返回的值即为替代每次匹配到的内容。</p>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript选择排序</title>
    <url>/2021/12/14/JavaScript%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多(n-1)次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h2 id="算法实现逻辑"><a href="#算法实现逻辑" class="headerlink" title="算法实现逻辑"></a>算法实现逻辑</h2><p>选择排序算法，从数组的开头开始，将第一个元素和其他元素进行比较，检查完所有元素后，最小的元素会放在数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便完成了排序。</p>
<h2 id="JavaScript代码实现选择排序"><a href="#JavaScript代码实现选择排序" class="headerlink" title="JavaScript代码实现选择排序"></a>JavaScript代码实现选择排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javacript二叉树算法剖析</title>
    <url>/2021/12/14/Javacript%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>树是计算机科学中经常用到的一种数据结构，树是一种非线性的数据结构，以分层的方式存储数据。树被用来存储具有层级关系的数据，比如文件系统中的文件；树还被用来存储有序列表。今天，我们来谈一谈一种特殊的树：二叉树。为什么选择二叉树，因为在二叉树上查找非常快，为二叉树添加或删除元素也非常快（而对数组执行添加和删除操作则不是这样）。</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是一种非线性的数据结构。要理解树的概念及其术语的含义，用一个例子说明是最好的办法。如下图所示就是一棵树，它是若干结点（A、B、C等都是结点）的集合，是由唯一的根（结点A）和若干互不相交的子树（如B、E、F这3个结点组成的树就是一颗子树）组成的。其中每一颗子树又是一棵树，也是由唯一的根结点和若干棵互不相交的子树组成的。由此可知，树的定义是递归 的，即在树的的一种又用到了树的定义。要注意的是，树的结点数目可以为0，当为0时，这棵树为一颗空树，不存在任何结点，这是一种极其特殊的情况。<br><a href="https://img-blog.csdnimg.cn/20190311120318897.png"><img src="https://img-blog.csdnimg.cn/20190311120318897.png"></a></p>
<h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p>以下皆以上图为例</p>
<p><strong>结点</strong>：图中A,B,C等都是结点，结点不仅包含数据元素，而且包含指向子树的分支。例如，A结点不仅包含数据元素A，而且包含3个指向子树的指针。</p>
<p><strong>结点的度</strong>：结点拥有的子树个数或者分支的个数。例如，A结点有三棵子树，所以A结点的度为3。</p>
<p><strong>树的度</strong>：树中各结点度的最大值。例如，上图中这棵树的度就为3，因为所有的结点中，以A结点拥有的子树最多，所以整棵树的度就取A结点的度，即为3。</p>
<p><strong>叶子结点</strong>：又叫作终端结点，指的是没有子结点的结点，也可以说度为0的结点，例如，E,F,G都时叶子结点。</p>
<p><strong>非终端结点</strong>：又叫作分支结点，指度不为0的结点，如A,B,C,D结点都是非终端结点，除了根结点之外的非终端结点，也叫作内部结点，如B,C,D都是内部结点。</p>
<p><strong>孩子</strong>：结点的子树的根。如A结点的孩子为B,C,D。</p>
<p><strong>双亲</strong>：与孩子的定义对应，如B,C,D的结点的双亲都是A。</p>
<p><strong>兄弟</strong>：同一个双亲的孩子之间互称为兄弟。如B,C,D互为兄弟，因为它们都是A结点的孩子。</p>
<p><strong>祖先</strong>：从根到某结点的路径上的所有结点，都是这个结点的祖先。如F结点的祖先为A和B，因为从A到F的路径为A-B-F。</p>
<p><strong>子孙</strong>：以某结点为根的子树中的所有结点，都是这个结点的子孙。如B结点的子孙为E,F。</p>
<p><strong>层次</strong>：从根开始，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层，以此类推。</p>
<p><strong>树的高度（或者深度）</strong>：树中结点的最大层次。如上例中的树共有3层，所以深度为3。</p>
<p><strong>结点的深度或高度</strong>：结点深度是从根结点算起的，根结点的深度为1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为1。</p>
<p><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟。如F和G互为堂兄弟，因为G的双亲为D，F结点的双亲为B，而B和D在同一层上。注意堂兄弟和兄弟之分。</p>
<p><strong>有序树</strong>：树中结点的子树从左到右是有次序的，不能交换，这样的树叫作有序树。</p>
<p><strong>无序树</strong>：树中结点的子树没有顺序，可以任意交换，这样的树叫作无序树。</p>
<p><strong>丰满树</strong>：丰满树即理想平衡树，要求除最底层外其他层都是满的。</p>
<p><strong>森林</strong>：若干棵互不相交的树的集合。例子中如果把根A去掉，剩下的3棵子树互不相交，它们组成一个森林。</p>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>在理解了树的定义之后，二叉树的定义也就很好理解了。将一般的树加上两个限制条件就可以得到二叉树：</p>
<p>（1）每个结点最多只有两棵子树，即二叉树中结点的度只能为0，1，2；</p>
<p>（2）子树有左右之分，不能颠倒；</p>
<h2 id="二叉树的主要性质"><a href="#二叉树的主要性质" class="headerlink" title="二叉树的主要性质"></a>二叉树的主要性质</h2><p><strong>性质1</strong>：非空二叉树上叶子结点数等于双分支节点数加1；</p>
<p><strong>性质2</strong>：二叉树的第 k 层上最多有(k &gt;= 1)个结点；</p>
<p><strong>性质3</strong>：高度（或深度）为 k 的二叉树最多有（k &gt;= 1）个结点。换句话说，满二叉树前 k 层的结点个数为；</p>
<p><strong>性质4</strong>： 有 n 个结点的完全二叉树，对各结点从上到下，从左到右依次编号（编号范围为 1 ~ n），则结点之间有如下关系：</p>
<p>若 k 为某个结点 a 的编号，则：</p>
<p>如果 k ≠ 1，则 a 的双亲结点的编号为 ；</p>
<p>如果 2k ≤ n，则 a 结点的左孩子的编号为 2k；</p>
<p>如果 2k &gt; n，则 a 结点无左孩子；</p>
<p>如果 2k + 1 ≤ n，则 a 结点的右孩子的编号为 2k + 1；</p>
<p>如果 2k + 1 &gt; n，则 a 结点无右孩子。</p>
<p><strong>性质5</strong>：Catalan函数：给定 n 个结点，能构成h(n)种不同的二叉树，h(n) = <a href="https://private.codecogs.com/gif.latex?C_%7B2n%7D%5E%7Bn%7D/(n%20&plus;%201)"><img src="https://private.codecogs.com/gif.latex?C_%7B2n%7D%5E%7Bn%7D/(n%20&plus;%201)"></a>；</p>
<p><strong>性质6</strong>：具有 n 个结点的完全二叉树的高度（或深度）为<img src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clceil%20log_%7B2%7D(n&plus;1)%20%5Cright%20%5Crceil">  或者<img src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clfloor%20log_%7B2%7Dn%20%5Cright%20%5Crfloor&plus;1"> .</p>
<h2 id="使用Javascript实现二叉查找树"><a href="#使用Javascript实现二叉查找树" class="headerlink" title="使用Javascript实现二叉查找树"></a>使用Javascript实现二叉查找树</h2><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左结点中，较大的值保存在右结点中。正是这一特性使得其查找效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。</p>
<p>由于个人喜好，以下代码皆以typescript来进行，用JS亦可。</p>
<p>二叉查找树由结点组成，我们先定义一个用来实现二叉查找树中的结点的类，简单的分析，可以知道，每个结点都有左右结点，所以，我们不妨为此类添加实例属性left和right，用来保存其左右结点，初始化都为null，再添加一个实例属性data用来保存结点数据。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line">  <span class="attr">data</span>: number | string</span><br><span class="line">  <span class="attr">left</span>: BinaryNode</span><br><span class="line">  <span class="attr">right</span>: BinaryNode</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">data: number | string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，结点依然准备完毕，接下来我们就来创建二叉查找树的类，简单的分析，首先每棵树都有一个根结点，所以我们为二叉查找树的类添加一个实例属性root用来保存此树的根结点，根结点初始化为null：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">  <span class="attr">root</span>: BinaryNode</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们要为树添加一个方法用来插入数据节点，我们知道，在二叉查找树中，较小的值分布在左子树，较大的值分布在右子树；较小的值放在左结点，较大的值放在右结点；那么，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">insert(data: number | string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = <span class="keyword">new</span> BinaryNode(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private insertNode(node: BinaryNode, <span class="attr">data</span>: string | number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = <span class="keyword">new</span> BinaryNode(data)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">this</span>.insertNode(node.left, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = <span class="keyword">new</span> BinaryNode(data)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">this</span>.insertNode(node.right, data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里声明了两个方法用来实现插入数据操作，insert方法用来进行插入数据，insertNode实现具体的插入过程，可以看到，插入数据的过程其实是递归的进行比较的过程（因insertNode方法没必要对外包暴漏，所以这里进行了私有化）。</p>
<p>那么，我们简单的插入一组数据试试看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tree: BinaryTree = <span class="keyword">new</span> BinaryTree</span><br><span class="line"></span><br><span class="line">tree.insert(<span class="number">23</span>)</span><br><span class="line">tree.insert(<span class="number">45</span>)</span><br><span class="line">tree.insert(<span class="number">16</span>)</span><br><span class="line">tree.insert(<span class="number">37</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line">tree.insert(<span class="number">99</span>)</span><br><span class="line">tree.insert(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tree)</span><br></pre></td></tr></table></figure>

<p>输入如下：<br><img src="https://img-blog.csdnimg.cn/20190312220550314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></p>
<p>可以很明显的看到，二叉查找树已经按照预期实现了，数据插入也符合预期，较大的值在右子树上，较小的值在左子树上；较小的值在左结点上，较大值在右结点上。</p>
<h2 id="二叉查找树的遍历"><a href="#二叉查找树的遍历" class="headerlink" title="二叉查找树的遍历"></a>二叉查找树的遍历</h2><h3 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="1. 中序遍历"></a>1. 中序遍历</h3><p>中序遍历按照结点上的键值，以升序访问树上的所有结点，先访问左子树，再访问根结点，后访问右子树。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inOrder(node: BinaryNode): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.inOrder(node.left)</span><br><span class="line">      <span class="built_in">console</span>.log(node.data)</span><br><span class="line">      <span class="built_in">this</span>.inOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们值是简单的将结点的值打印在控制台中，你完全可以选择进行其他的操作。我们调用一下中序遍历的方法，如下：</p>
<p><code>tree.inOrder(tree.root)</code></p>
<p>发现控制台输出如下：<br><a href="https://img-blog.csdnimg.cn/20190312221503144.png"><img src="https://img-blog.csdnimg.cn/20190312221503144.png"></a></p>
<p>很明显的发现，结点数据会以升序的方式进行排序。</p>
<h3 id="2-先序遍历"><a href="#2-先序遍历" class="headerlink" title="2. 先序遍历"></a>2. 先序遍历</h3><p>由上述，我们知道中序遍历可以对树上的节点数据进行升序排序，那么先序遍历的意义是什么呢？先序遍历对一棵二叉树进行复制，要知道复制一颗二叉树的效率要比重新创建一棵二叉树高得多，复制一棵二叉树的算法复杂度为O(n)，而新创建一棵二叉树的算法复杂度为O(nlogn)，所以这就是研究先序遍历的意义。先序遍历先访问根结点，再访问左子树，最后访问右子树。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">preOrder(node: BinaryNode): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(node.data)</span><br><span class="line">      <span class="built_in">this</span>.preOrder(node.left)</span><br><span class="line">      <span class="built_in">this</span>.preOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么，我们也不妨调用一下看看：</p>
<p><code>tree.preOrder(tree.root)</code></p>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190312222430187.png"><img src="https://img-blog.csdnimg.cn/20190312222430187.png"></a></p>
<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><p>后序遍历，先访问左子树，在访问右子树，最后访问根结点。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">postOrder(node: BinaryNode): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.postOrder(node.left)</span><br><span class="line">      <span class="built_in">this</span>.postOrder(node.right)</span><br><span class="line">      <span class="built_in">console</span>.log(node.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>调用一下：</p>
<p><code>tree.postOrder(tree.root)</code></p>
<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190312222720737.png"><img src="https://img-blog.csdnimg.cn/20190312222720737.png"></a></p>
<h2 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h2><p>那么，在二叉查找树怎么找到某一个数据的结点呢？我们提供了一个查找数据结点的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">findNode(node: BinaryNode, <span class="attr">data</span>: string | number): BinaryNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.data === data) &#123;</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.data &gt; data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.findNode(node.left, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">this</span>.findNode(node.right, data)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>调用一下看看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(tree.findNode(tree.root, <span class="number">37</span>));</span><br><span class="line"><span class="built_in">console</span>.log(tree.findNode(tree.root, <span class="number">137</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/2019031222312567.png"><img src="https://img-blog.csdnimg.cn/2019031222312567.png"></a></p>
<p>很明显，第二个结点并不存在于此树中，所以返回了null。</p>
<h2 id="查找最大值和最小值结点"><a href="#查找最大值和最小值结点" class="headerlink" title="查找最大值和最小值结点"></a>查找最大值和最小值结点</h2><p>我们知道，二叉查找树中，较小的值分布再左子树，较大的树分布在右子树，所以，这也为我们寻找最大值和最小值结点提供了思路，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取最小值节点</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;BinaryNode&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@memberof <span class="variable">BinaryTree</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getMinNode(node: BinaryNode): BinaryNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取二叉树最大值节点</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;BinaryNode&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@memberof <span class="variable">BinaryTree</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getMaxNode(node: BinaryNode): BinaryNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>不妨来实验一下，调用一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(tree.getMinNode(tree.root));</span><br><span class="line"><span class="built_in">console</span>.log(tree.getMaxNode(tree.root));</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190312223622781.png"><img src="https://img-blog.csdnimg.cn/20190312223622781.png"></a></p>
<p>其实，这两个方法也可以用来查找子树的最大值和最小值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = tree.findNode(tree.root, <span class="number">45</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tree.getMinNode(node))</span><br><span class="line"><span class="built_in">console</span>.log(tree.getMaxNode(node))</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190312224014886.png"><img src="https://img-blog.csdnimg.cn/20190312224014886.png"></a></p>
<p>可以发现，也如预期的找出了子树中的最大值和最小值。</p>
<h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p>重头戏来了，二叉查找树最复杂的部分就是删除某个结点的操作，其复杂程度取决于删除哪个结点。如果删除没有子结点的结点，那么非常简单。如果结点只有一个子结点，不管是左结点还是右结点，就变得稍微有点复杂了。删除包含两个子结点的结点最复杂。</p>
<p>简单的分析一下先，如果删除的是叶子结点（没有子结点的结点），那么只需要将只需将原本指向它的父结点指向的链接指向null即可；如果删除的结点只包含一个子结点，那么原本指向它的结点就得做些调整，使其指向它的子结点；最后，如果待删除的结点包含两个子结点，正确的做法有两种：要么查找待删除结点的左子树上的最大值，要么查找待删除结点右子树上的最小值。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">remove(data: number | string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.root, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private removeNode(node: BinaryNode, <span class="attr">data</span>: number | string): BinaryNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>.removeNode(node.left, data)</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, data)</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> tempNode = <span class="built_in">this</span>.getMinNode(node.right)</span><br><span class="line">      node.data = tempNode.data</span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, tempNode.data)</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript错误捕获</title>
    <url>/2022/01/01/Javascript%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="同步代码错误捕获try-carch"><a href="#同步代码错误捕获try-carch" class="headerlink" title="同步代码错误捕获try,carch"></a>同步代码错误捕获try,carch</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">let</span> c = a + b</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise错误捕获unhandledrejection"><a href="#Promise错误捕获unhandledrejection" class="headerlink" title="Promise错误捕获unhandledrejection"></a>Promise错误捕获unhandledrejection</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	reject(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e)</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e)</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载跨域资源时，会提示Script error，需要添加跨域相关属性</span></span><br><span class="line"><span class="comment">// 客户端添加crossorigin属性</span></span><br><span class="line"><span class="comment">// 服务端添加Access-Control-Allow-Origin: *</span></span><br><span class="line"><span class="comment">// 否则只提示Script error，无法获取具体错误信息</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/redux/4.1.0/redux.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上就是JavaScript捕获错误的方法，若有补充请留言。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios连续请求同一个接口的时候取消前一个请求</title>
    <url>/2022/01/01/axios%E8%BF%9E%E7%BB%AD%E8%AF%B7%E6%B1%82%E5%90%8C%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%96%E6%B6%88%E5%89%8D%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>使用axios怎样在连续请求同一个接口时，取消前面的请求，通俗一点来讲就是对接口请求做了个“防抖”的操作。场景：比如现在页面上有个列表查询的按钮，当用户在一秒钟之内，多次点击这个按钮时，那么接口此接口请求会发生多次，前一个接口请求结果还未返回就进行了下一次请求，这样做不但会造成资源的浪费，同时还会加重服务端的压力，怎样避免这样的操作呢？此时，我们只需要在下一个接口发出时，取消前面这个一模一样的接口的请求即可。</p>
<p>幸运的是axios给我们提供了这样的一个骚操作：cancelToken。</p>
<p>话不多说，直接上code：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = axios.create()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Cancel = axios.CancelToken</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> httpPending = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHttpPending</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  httpPending.map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.u === config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;config.url&#125;</span>: 短时间内重复请求`</span>)</span><br><span class="line">      item.f()</span><br><span class="line">      arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearHttpPending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  httpPending = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  removeHttpPending(config)</span><br><span class="line">  config.cancelToken = <span class="keyword">new</span> Cancel(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    httpPending.push(&#123; <span class="attr">u</span>: config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method, <span class="attr">f</span>: c &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  clearHttpPending()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>大致思路是在请求拦截器中，把请求缓存在一个数组中，然后在每次请求的时候，对数组进行检索，如果存在未完成的请求，则执行取消请求的操作，注意这里取消的是上一个还未完成的请求，并不是此次请求。那么怎样取消请求呢，请看这一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.cancelToken = <span class="keyword">new</span> Cancel(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    httpPending.push(&#123; <span class="attr">u</span>: config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method, <span class="attr">f</span>: c &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码在请求拦截器中对此次请求进行了储存，config.cancelToken等于new了一个Cancel类的实例，其中的参数为一个回调函数，回调函数的参数即是可以取消此次请求的函数，执行这个函数即可取消此次请求操作。需要说明的是，取消请求操作，是不会有数据返回的，也就是不会走到响应拦截器中的代码，如果走到了响应拦截器，那就说明此次接口请求之后，短时间内没有紧接着的密集的同类请求，所以，我们需要在响应拦截器中对储存的接口缓存数组进行清空操作，这也就是函数clearHttpPending的存在的原因。</p>
<p>另外，再来说一说最重要的函数removeHttpPending，即取消前一次请求的函数。先来看在请求拦截器中的cancelToken的时候进行储存的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.cancelToken = <span class="keyword">new</span> Cancel(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    httpPending.push(&#123; <span class="attr">u</span>: config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method, <span class="attr">f</span>: c &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>数组httpPending进行push的这个对象{ u: config.url + ‘&amp;’ + config.method, f: c }，这个对象是我们自己定义的，u代表此次请求的标识，也就是你在后面执行取消操作的时候，怎么知道你上一个请求和此次请求是属于对同一个接口发起的一模一样的请求，这里我们采用的是请求的路径url和方法method，键f存的是取消请求的函数c。<br>所以，在函数removeHttpPending中，我们对config的url和method拼接起来的字符串和数组中已经储存的对象的键u进行比较，如果相同，则说明上一个请求和此次请求是属于同一个请求，如果满足这个判断，则需要进行取消请求的操作，即要执行对象中已经储存的键f的值c函数。所以，函数removeHttpPending就变成了这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHttpPending</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  httpPending.map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.u === config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;config.url&#125;</span>: 短时间内重复请求`</span>)</span><br><span class="line">      item.f()</span><br><span class="line">      arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要更严谨一些，那么在函数removeHttpPending还要对请求参数进行验证，如满足了url和method相同外，还要满足请求参数也是一样的，才取消请求。如此，我们可以这样改造函数removeHttpPending，请看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHttpPending</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  httpPending.map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item.u === config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(item.data &amp;&amp; isSameKeyValueObj(item.data, config.data)) &amp;&amp; !(item.params &amp;&amp; isSameKeyValueObj(item.params, config.params))) &#123;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;config.url&#125;</span>: 短时间内重复请求`</span>)</span><br><span class="line">      item.f()</span><br><span class="line">      arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">Object</span>.prototype.toString.call(obj)</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;[object Object]&#x27;</span> || str === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameKeyValueObj</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObj(target) || !isObj(source)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> targetkeys = <span class="built_in">Object</span>.getOwnPropertyNames(target)</span><br><span class="line">  <span class="keyword">const</span> sourcekeys = <span class="built_in">Object</span>.getOwnPropertyNames(source)</span><br><span class="line">  <span class="keyword">if</span> (targetkeys.length !== sourcekeys.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; targetkeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = targetkeys[i]</span><br><span class="line">    <span class="keyword">if</span> (!isObj(target[key]) &amp;&amp; target[key] !== source[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObj(target[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> isSameObj(target[key], source[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相应的请求拦截器中的代码变成了如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  removeHttpPending(config)</span><br><span class="line">  config.cancelToken = <span class="keyword">new</span> Cancel(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    httpPending.push(&#123;</span><br><span class="line">      <span class="attr">u</span>: config.url + <span class="string">&#x27;&amp;&#x27;</span> + config.method,</span><br><span class="line">      <span class="attr">f</span>: c,</span><br><span class="line">      <span class="attr">data</span>: config.data,</span><br><span class="line">      <span class="attr">params</span>: config.params</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如此，我们就完成了对请求更加严谨的判断，即除了对url和方法method进行对比外，还加入了data和params的对比。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习日记《二》类型兼容性（协变、逆变、双变和抗变）</title>
    <url>/2022/06/18/TypeScript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E3%80%8A%E4%BA%8C%E3%80%8B%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%88%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8F%8C%E5%8F%98%E5%92%8C%E6%8A%97%E5%8F%98%EF%BC%89/</url>
    <content><![CDATA[<h2 id="类型父子关系的判断"><a href="#类型父子关系的判断" class="headerlink" title="类型父子关系的判断"></a>类型父子关系的判断</h2><p>像 java 里面的类型都是通过 extends 继承的，如果 A extends B，那 A 就是 B 的子类型。这种叫做<strong>名义类型系统（nominal type）</strong>。</p>
<p>而 ts 里不看这个，只要结构上是一致的，那么就可以确定父子关系，这种叫做<strong>结构类型系统（structual type）</strong>。</p>
<p><strong>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。</strong><br>ts 类型兼容：<br>当一个类型 Y 的值可以赋值给另一个类型 X 的值时， 我们就可以说类型 X 兼容类型 Y。也就是说两者在结构上是一致的，而不一定非得通过 extends 的方式继承而来；<br><strong>接口的兼容性</strong>：<code>x = y</code> 只要目标类型 X 的值x中声明的属性变量在源类型 Y 的值y中都存在就是兼容的（ Y 中的类型可以比 X 中的多，但是不能少）；<br><strong>函数的兼容性</strong>：<code>x = y</code>  Y 的每个参数必须能在 X 里找到对应类型的参数，参数的名字相同与否无所谓，只看它们的类型（参数可以少但是不能多。与接口的兼容性有区别）。</p>
<p><strong>支持子类对象赋值给父类对象的情况称之为协变；反之，支持父类对象赋值给子类对象的情况称之为逆变。</strong>(注意：这里所说的子类不一定是通过继承关系的子类，而是类型结构上的相同)。</p>
<p><strong>协变</strong>：<code>X = Y</code> Y 类型可以赋值给 X 类型的情况就叫做协变，也可以说是 X 类型兼容 Y 类型；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Person &#123; name: string; age: number; &#125; </span><br><span class="line">interface Man &#123; name: string; age: number; hobbies: string[] &#125;</span><br><span class="line">let person: Person = &#123; name: &#x27;xiaoming&#x27;, age: 16 &#125;</span><br><span class="line">let man: Man = &#123; name: &#x27;xiaohong&#x27;, age: 18, hobbies: [&#x27;eat&#x27;] &#125;</span><br><span class="line">person = man   // OK</span><br><span class="line">man = person   // Error</span><br></pre></td></tr></table></figure>

<p><strong>逆变</strong>：printY = printX 函数X 类型可以赋值给函数Y 类型，因为函数Y 在调用的时候参数是按照Y类型进行约束的，但是用到的是函数X的X的属性和方法，ts检查结果是类型安全的。这种特性就叫做逆变，<strong>函数的参数有逆变的性质（而返回值是协变的，也就是子类型可以赋值给父类型）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let printY: (man: Man) =&gt; void</span><br><span class="line">printY = (man) =&gt; &#123; console.log(man.hobbies) &#125;</span><br><span class="line">let printX: (p: Person) =&gt; void</span><br><span class="line">printX = (p) =&gt; &#123; console.log(p.name) &#125;</span><br><span class="line">printY = printX  // OK</span><br><span class="line">printX = printY  // Error</span><br></pre></td></tr></table></figure>

<p><strong>双变（双向协变）</strong>：<code>x = y</code>；<code>y = x</code>父类型的值可以赋值给子类型的值，子类型的值可以赋值给父类型的值，既逆变又协变，叫做“双向协变”（ts2.x 之前支持这种赋值，之后 ts 加了一个编译选项 <code>strictFunctionTypes</code>，设置为 <code>true</code> 就只支持函数参数的逆变，设置为 <code>false</code> 则支持双向协变）；</p>
<p><strong>抗变（不变）</strong>：非父子类型之间不会发生型变，只要类型不一样就会报错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ts 通过给 js 添加了静态类型系统来保证了类型安全，大多数情况下不同类型之间是不能赋值的，但是为了增加类型系统灵活性，设计了父子类型的概念。父子类型之间自然应该能赋值，也就是会发生型变。</p>
<p>型变分为<strong>逆变</strong>和<strong>协变</strong>。<strong>协变很容易理解，就是子类型赋值给父类型</strong>。<strong>逆变主要是函数赋值的时候函数参数的性质，参数的父类型可以赋值给子类型</strong>，这是因为按照子类型来声明的参数，访问父类型的属性和方法自然没问题，依然是类型安全的。但反过来就不一定了。</p>
<p>不过 ts 2.x 之前反过来依然是可以赋值的，也就是既逆变又协变，叫做双向协变。</p>
<p>为了更严格的保证类型安全，ts 添加了 <code>strictFunctionTypes</code> 的编译选项，开启以后(设置为true)函数参数就只支持逆变，否则支持双向协变。</p>
<p>型变都是针对父子类型来说的，非父子类型自然就不会型变也就是不变。</p>
<p>ts 中父子类型的判定是按照结构来看的，更具体的那个是子类型。</p>
<p>理解了如何判断父子类型（结构类型系统），父子类型的型变（逆变、协变、双向协变），很多类型兼容问题就能得到解释了。</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>cnpm全局安装（淘宝镜像）</title>
    <url>/2021/12/12/cnpm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%EF%BC%88%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%EF%BC%89/</url>
    <content><![CDATA[<p>安装淘宝npm（cnpm）</p>
<p>安装cnpm</p>
<p>输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>css居中大全集</title>
    <url>/2022/01/01/css%E5%B1%85%E4%B8%AD%E5%A4%A7%E5%85%A8%E9%9B%86/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在实际开发过程中，我们会碰到很多需要用到水平垂直居中的场景，为了方便大家的开发，特此做下总结和记录。话不多说，进入正题（温馨提示：以下所说的居中是相对于父盒子而言）。</p>
<h2 id="1-父盒子使用flex布局控制子盒子水平垂直居中"><a href="#1-父盒子使用flex布局控制子盒子水平垂直居中" class="headerlink" title="1.父盒子使用flex布局控制子盒子水平垂直居中"></a>1.父盒子使用flex布局控制子盒子水平垂直居中</h2><p>例如：</p>
<p>html部分：<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>css部分：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">         <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">         <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">         <span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line">         <span class="attribute">display</span>: flex;</span><br><span class="line">         <span class="attribute">justify-content</span>: center;</span><br><span class="line">         <span class="attribute">align-items</span>: center;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="selector-class">.son</span> &#123;</span><br><span class="line">         <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">         <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">         <span class="attribute">background-color</span>: hotpink;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<h2 id="2-需要居中的盒子自身使用定位配合margin"><a href="#2-需要居中的盒子自身使用定位配合margin" class="headerlink" title="2.需要居中的盒子自身使用定位配合margin"></a>2.需要居中的盒子自身使用定位配合margin</h2><p>html部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.center &#123;</span><br><span class="line">         background-color: deepskyblue;</span><br><span class="line">         width: 100px;</span><br><span class="line">         height: 100px;</span><br><span class="line">         position: absolute;</span><br><span class="line">         top: <span class="number">0</span>;</span><br><span class="line">         right: <span class="number">0</span>;</span><br><span class="line">         bottom: <span class="number">0</span>;</span><br><span class="line">         left: <span class="number">0</span>;</span><br><span class="line">         margin: auto;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这里的margin：auto；并不能省略，切记！！！</p>
<h2 id="3-定位结合transform的translate属性"><a href="#3-定位结合transform的translate属性" class="headerlink" title="3.定位结合transform的translate属性"></a>3.定位结合transform的translate属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.center &#123;</span><br><span class="line">     background-color: deepskyblue;</span><br><span class="line">     width: 100px;</span><br><span class="line">     height: 100px;</span><br><span class="line">     position: absolute;</span><br><span class="line">     top: <span class="number">50</span>%;</span><br><span class="line">     left: <span class="number">50</span>%;</span><br><span class="line">     transform: translate(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>css画正方体</title>
    <url>/2022/06/21/css%E7%94%BB%E6%AD%A3%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p>怎样利用css画一个正方体呢？<br>话不多说，直接上代码：<br>首先是html结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner top&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner bottom&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner front&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner back&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">        <span class="attribute">animation</span>: move <span class="number">5s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid hotpink;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">155</span>,<span class="number">150</span>,<span class="number">26</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(-<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里还没完，目前的效果是叠在一起的，还需要加一个视角。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">200px</span> <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">perspective</span>: <span class="number">2400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最外层元素app的盒子上加perspective属性，perspective的意义在于设置远近点大小的比例，让它产生3D感，但是并不改变物体在transform-origin处的大小。<br>为了能看得更加清楚全面，我们给盒子加个动画，所以最终代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">200px</span> <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">perspective</span>: <span class="number">2400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">	<span class="attribute">animation</span>: move <span class="number">5s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid hotpink;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">155</span>,<span class="number">150</span>,<span class="number">26</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(-<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">	<span class="number">0%</span> &#123;</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">0</span>) <span class="built_in">rotateX</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="number">100%</span> &#123;</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">360deg</span>) <span class="built_in">rotateX</span>(<span class="number">360deg</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>git将某分支的某次提交合并到别的分支</title>
    <url>/2021/12/31/git%E5%B0%86%E6%9F%90%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%90%88%E5%B9%B6%E5%88%B0%E5%88%AB%E7%9A%84%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天我们来学习一下git，git在我们进行代码托管时的首选，所以了解并学会使用git是每个开发人员的必备技能。</p>
<p>在进行代码开发的时候，有时需要把某分支（比如dev分支）的某一次提交合并到另一分支（比如hotfix分支），这就需要用到git cherry-pick命令。</p>
<h2 id="1-使用命令行"><a href="#1-使用命令行" class="headerlink" title="1.使用命令行"></a>1.使用命令行</h2><p>首先，切换到dev分支，敲 git log 命令，查找需要合并的commit记录，比如commitID：<code>8a645bf5</code>；</p>
<p>然后，切换到hotfix分支，使用 <code>git cherry-pick 8a645bf5</code>命令，就把该条commit记录合并到了hotfix分支，这只是在本地合并到了hotfix分支；</p>
<p>最后，git push 提交到master远程，至此，就把dev分支的这条commit所涉及的更改合并到了hotfix分支。</p>
<h2 id="2-使用图形化工具Sourcetree"><a href="#2-使用图形化工具Sourcetree" class="headerlink" title="2.使用图形化工具Sourcetree"></a>2.使用图形化工具Sourcetree</h2><p>首先切换到你要合并到的分支，也就是目的地分支（比如hotfix），然后下拉框选中由当前分支选中所有分支，查看所有提交，找到别的分支的某次提交（也就是你想合并的那次提交，比如dev分支的某次commit），然后鼠标点击此次提交，右键点击然后选中菜单的遴选即可，然后你会发现已经将此次提交合并到了本地hotfix，最后push到远程hotfix分支，即完成。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>https原理</title>
    <url>/2021/12/31/https%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天我们要讨论的主题是HTTPS，首先，我们要了解为什么会出现HTTPS？既然存在，就有它存在的必要性。我们都知道，HTTP协议是客户端和服务端进行通信的一种协议，而HTTP协议存在以下几个缺点：</p>
<p>1.通信采用明文传输（不加密），内容容易遭到窥视；</p>
<p>2.不验证通信方的身份，因此有可能遭到伪装；</p>
<p>3.无法证明报文的完整性，因此通信内容有可能被篡改；</p>
<p>正因为HTTP的诸多缺陷，才有了后面HTTPS诞生的必要性，HTTPS正是为了解决HTTP的诸多缺陷而诞生。</p>
<h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><p>刚才说了，HTTPS的产生就是为了解决HTTP协议存在的主要缺陷，而通过上面的介绍，我们知道HTTP协议的主要缺陷有：未加密，没认证身份和无法确保报文的完整性，所以我们可以用一句最简短的话讲明白HTTPS，那就是：HTTP + 加密 + 认证 + 完整性保护 = HTTPS。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>HTTP协议中没有加密机制，但可以通过和<strong>SSL</strong>(Secure Socket Layer，安全套接层)或<strong>TLS</strong>(Transport Layer Security，安全传输层协议)的组合使用，加密HTTP的通信内容。</p>
<p><strong>SSL</strong>的全称是<strong>Secure Sockets Layer</strong>，即安全套接层协议，主要任务是提供<strong>加密</strong>，<strong>身份认证</strong>和<strong>信息完整性保护</strong>一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0。</p>
<p>TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是<strong>它们所支持的加密算法不同</strong>，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p>
<p>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信，与SSL组合使用的HTTP就是HTTPS（超文本传输安全协议）。我们都知道HTTP协议是属于应用层的一种协议，TCP协议是传输层的协议，使用HTTP协议进行通信时，HTTP直接和TCP连接，而当我们使用HTTPS进行通信时，即使用 HTTP + SSL 进行通信时，在应用层和传输层之间增加了一层安全层，即SSL。换句话说，当使用HTTPS进行通信时，HTTP协议发送的报文不再直接发送给TCP，而是先经过安全层，即经由SSL将报文加密再发送给TCP。</p>
<p>在采用SSL之后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。我们先来了解一下加密方法。</p>
<h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><p>加密和解密使用同一个密钥的方式称为对称密钥加密。对称加密的特点是<strong>算法公开、加密和解密速度快</strong>，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p>
<p>使用对称密钥加密的方式进行加密时，必须将密钥发送给对方，可究竟怎样才能安全的移交？在互联网上发送密钥时，如果通信被窥视，那么密钥就有可能落入攻击者之手，同时也失去了加密的意义。另外还得设法安全的保管接收到的密钥。</p>
<p>由此，我们可以总结，对于对称密钥加密，其优点是：<strong>加密和解密速度快，效率高，适合于对大数据量进行加密</strong>；其缺点是：<strong>密钥的安全移交和保管变得异常困难</strong>。</p>
<h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><p>非对称密钥加密可以很好的解决对称密钥加密的困境。其加密使用一对非对称的密钥，一把叫做公钥，另一把叫做私钥。私钥保存在服务端，不能让任何人知道，公钥则可以随意发布，任何人都可以获取。公钥和私钥成对的加密和解密，即若使用公钥加密，则必须使用私钥对密文进行解密，同理，若使用私钥加密，则必须使用公钥对密文进行解密。在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>
<p>对于非对称密钥加密，其优点是：<strong>密钥安全性好，私钥无法获取</strong>；其缺点是：<strong>加密和解密花费时间长、速度慢，只适合对少量数据进行加密</strong>。</p>
<h3 id="HTTPS加密原理"><a href="#HTTPS加密原理" class="headerlink" title="HTTPS加密原理"></a>HTTPS加密原理</h3><p><strong>HTTPS = HTTP协议 + SSL/TLS协议</strong>，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。</p>
<p>HTTPS充分利用了对称密钥加密和非对称密钥加密二者的优势，为了兼顾安全与效率，同时使用了对称密钥加密和非对称密钥加密。在交换密钥环节使用非对称密钥加密方式，之后的建立通信交换报文阶段则采用对称密钥加密方式。即，正式通信的数据传输采用对称密钥加密，而对称密钥加密的密钥则采用非对称密钥加密的方式，由客户端经过非对称密钥加密的公钥进行加密后发送给服务端，服务端利用其独有的私钥进行解密拿到以后数据传输加密的密钥。如此结合二者，也不怕攻击者拿到由客户端发给服务端的密文，即使拿到了也没法解密，因为对称加密的密钥是经过非对称加密的公钥进行加密的，所以想要解密只能使用私钥进行解密，而私钥为服务端所独有，所以只有服务端才可以解密得到后续对数据加密的对称加密的密钥。</p>
<p>如此<strong>混合加密</strong>的方式，<strong>既提高了效率，又解决密钥无法安全移交的困境</strong>。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>http判断缓存是否有效，为什么有了last-modified还需要etag呢？</title>
    <url>/2022/05/10/http%E5%88%A4%E6%96%AD%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86last-modified%E8%BF%98%E9%9C%80%E8%A6%81etag%E5%91%A2%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="If-Modified-Since："><a href="#If-Modified-Since：" class="headerlink" title="If-Modified-Since："></a>If-Modified-Since：</h2><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<hr>
<h2 id="ETag："><a href="#ETag：" class="headerlink" title="ETag："></a>ETag：</h2><p>是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>
<p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p>
<p>问题是，我们知道last-modified可以用来判断浏览器的本地缓存是否有效，那为什么还要使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题：</p>
<ol>
<li><p>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</p>
</li>
<li><p>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</p>
</li>
<li><p>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>js中viod运算符总结</title>
    <url>/2021/12/12/js%E4%B8%ADviod%E8%BF%90%E7%AE%97%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>简单来说，void运算符用于对给定的表达式进行求值，然后返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined">undefined</a>。该运算符通常用于避免输出不应该输出的值。</p>
<h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> expression</span><br></pre></td></tr></table></figure>
<h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>这个运算符能向期望一个表达式的值是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined">undefined</a>的地方插入会产生副作用的表达式。</p>
<p>void 运算符通常只用于获取 <code>undefined</code>的原始值，一般使用<code>void(0)</code>（等同于<code>void 0</code>）。在上述情况中，也可以使用全局变量<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined">undefined</a> 来代替（假定其仍是默认值）。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p>通过采用<code>void 0</code>取<code>undefined</code>比直接写<code>undefined</code>更靠谱更安全，应该优先采用<code>void 0</code>这种方式；</p>
<p>填充<code>&lt;a&gt;</code>的<code>href</code>确保点击时不会产生页面跳转；填充<code>&lt;image&gt;</code>的<code>src</code>，确保不会向服务器发出垃圾请求；</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在ES5之前，<code>window</code>下的<code>undefined</code>是可以被重写的，于是导致了某些极端情况下使用undefined会出现一定的差错。所以，用<code>void 0</code>是为了防止<code>undefined</code>被重写而出现判断不准确的情况。 ES5之后的标准中，规定了全局变量下的<code>undefined</code>值为只读，不可改写的，但是局部变量中依然可以对之进行改写。</p>
<p>非严格模式下，undefined是可以重写的，严格模式则不能重写。</p>
<p>除了防止被重写外，还可以减少字节。void 0代替undefined省3个字节。类似的还有很多常用的写法，下面介绍一些老司机的套路，嘿嘿。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取整</span></span><br><span class="line"><span class="built_in">parseInt</span>(a,<span class="number">10</span>); <span class="comment">// Before</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a); <span class="comment">// Before</span></span><br><span class="line">a&gt;&gt;<span class="number">0</span>; <span class="comment">// Before</span></span><br><span class="line">~~a; <span class="comment">// After</span></span><br><span class="line">a|<span class="number">0</span>; <span class="comment">// After</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.round(a); <span class="comment">// Before</span></span><br><span class="line">a+<span class="number">.5</span>|<span class="number">0</span>; <span class="comment">// After</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置值</span></span><br><span class="line"><span class="literal">undefined</span>; <span class="comment">// Before</span></span><br><span class="line"><span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// After, 快</span></span><br><span class="line"><span class="number">0</span>[<span class="number">0</span>]; <span class="comment">// After, 略慢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置值</span></span><br><span class="line"><span class="literal">Infinity</span>;</span><br><span class="line"><span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值短写法</span></span><br><span class="line"><span class="literal">true</span>; <span class="comment">// Before</span></span><br><span class="line">!<span class="number">0</span>; <span class="comment">// After</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值短写法</span></span><br><span class="line"><span class="literal">false</span>; <span class="comment">// Before</span></span><br><span class="line">!<span class="number">1</span>; <span class="comment">// After</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断奇偶数(装逼写法)</span></span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;n为奇数&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">&quot;n为偶数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除以2取整</span></span><br><span class="line"><span class="built_in">Math</span>.floor(n / <span class="number">2</span>)  <span class="comment">// Before</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span>  <span class="comment">// After</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js中一个好玩的api之queueMicrotask</title>
    <url>/2022/07/17/js%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84api%E4%B9%8BqueueMicrotask/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天闲来无聊，偶然看到个api – queueMicrotask，其MDN地址为<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" title="queueMicrotask">queueMicrotask</a>，觉得挺有意思的，于是想写一篇文章来跟大家分享一下。</p>
<hr>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先，这个api看字面意思就知道和微任务有关，至于js中的宏任务和微任务，我就不多说了，默认大家都知道这些东西，不了解的读者可以去查阅相关的资料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">queueMicrotask(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">/* ... */</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到，此api需要传入一个回调函数作为参数，然后以微任务的形式执行此回调函数，换言之，就是把此回调函数放入此次js事件循环的微任务队列中。</p>
<p>我们不妨来看几个例子：<br>例子1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">333</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">444</span>)</span><br></pre></td></tr></table></figure>
<p>那么，此例子中的代码执行结果是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">444</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>你猜对了吗？</p>
<hr>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>详情见<a href="https://caniuse.com/?search=queueMicrotask" title="queueMicrotask">queueMicrotask</a></p>
<hr>
<h2 id="queueMicrotask的polyfill"><a href="#queueMicrotask的polyfill" class="headerlink" title="queueMicrotask的polyfill"></a>queueMicrotask的polyfill</h2><p>如果当前环境不支持queueMicrotask，则可以像下面这样模拟：</p>
<h3 id="1-MDN"><a href="#1-MDN" class="headerlink" title="1.MDN"></a>1.MDN</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> queueMicrotask !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">  queueMicrotask = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      .then(callback)</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> e; &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-core-js"><a href="#2-core-js" class="headerlink" title="2.core-js"></a>2.core-js</h3><p>相比较 MDN 的实现，core-js 会复杂一些，它同时考虑了 nodejs 和 browser 两种情况，同时利用链表数据结构来模拟微任务队列的执行单元，同时实现了一个 flush 方法表示执行全部的微任务单元。</p>
<p>还实现了一个 notify 方法，该方法会根据具体的 js 运行时环境以及 api 的支持情况，分别尝试使用 process.nextTick、MutationObserver 和 Promise.resolve 以及最基本的宏任务 api 来执行 flush方法，变相模拟微任务的执行过程。</p>
<hr>
<h2 id="为什么我们需要这个-api？"><a href="#为什么我们需要这个-api？" class="headerlink" title="为什么我们需要这个 api？"></a>为什么我们需要这个 api？</h2><p>从微任务本身的概念来说的话，就是<strong>当我们期望某段代码，不阻塞当前执行的同步代码，同时又期望它尽可能快地执行时，我们就需要它</strong>。由于它是一个用于指派微任务的底层 api，我们很可能会在其中无限制地指派微任务到其队列之中，这样做的效果就是，浏览器的微任务队列始终处于非空状态，这将导致控制权始终无法交还给浏览器进行下一次事件循环，需要注意的是，不要长时间连续使用此api（比如递归），否则js的执行将一直在做添加微任务和清空微任务队列的工作，最终导致浏览器卡死，比如下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	queueMicrotask(infiniteFn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queueMicrotask(infiniteFn)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>let与var区别大总结</title>
    <url>/2021/12/25/let%E4%B8%8Evar%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-函数作用域与块级作用域"><a href="#1-函数作用域与块级作用域" class="headerlink" title="1. 函数作用域与块级作用域"></a>1. 函数作用域与块级作用域</h2><p>在ES6出现之前，JavaScript是没有块级作用域的概念的。ES6的横空出世带来了let和const代替之前的var声明变量和常量，由此也带来了块级作用域的概念。</p>
<p>我们来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">23</span></span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>上述输出两个23；</p>
<p>再来看let和const声明形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">23</span>;</span><br><span class="line">     <span class="keyword">const</span> NUM = <span class="number">6</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">     <span class="built_in">console</span>.log(NUM);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">   <span class="built_in">console</span>.log(NUM);</span><br></pre></td></tr></table></figure>

<p>上述输出如下：<br><a href="https://img-blog.csdnimg.cn/2019063021351789.png"><img src="https://img-blog.csdnimg.cn/2019063021351789.png"></a></p>
<p>很明显，在大括号外输出变量a和常量NUM是直接报错，没有定义！这已经充分说明let和const声明的变量具有块级作用域。</p>
<h2 id="2-关于变量提升"><a href="#2-关于变量提升" class="headerlink" title="2. 关于变量提升"></a>2. 关于变量提升</h2><p>我们知道由var声明的变量和function声明的函数会提升到当前作用域的最前边，而ES6出现的let和const声明的变量是不会进行提升的，请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>变量a用var的方式声明，var声明的变量会提升到当前作用域的最前方，上述代码实际会变成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a；</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">23</span>；</span><br></pre></td></tr></table></figure>

<p>再来看let和const声明的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">21</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>上述代码，会报错！在let和const声明之前就使用其声明的变量，会报错，这充分说明了let和const不存在变量提升；其实let和const会存在暂时性死区，在其所在的作用域内，直到其声明的地方之前，都不允许出现其要声明的变量，即暂时性死区，这更加充分的说明了let和const不存在变量提升。</p>
<h2 id="3-在for循环中的区别"><a href="#3-在for循环中的区别" class="headerlink" title="3. 在for循环中的区别"></a>3. 在for循环中的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>由 var 声明的变量，在for循环之外，依然可以拿到变量 i 的值。</p>
<p>我们再来看由 let 声明的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>上述代码在for循环之外输出变量 i 的值会报错，因为 let 声明的变量具有块级作用域的关系，所以在 for 循环中用 let 声明变量，在for循环之外是拿不到 i 的值的，换句话说就是不会污染for循环之外的变量。所以强烈建议各位同学在使用for循环时使用let声明循环变量。</p>
<h2 id="4-全局声明，var声明的会成为window对象的属性，let则不会"><a href="#4-全局声明，var声明的会成为window对象的属性，let则不会" class="headerlink" title="4. 全局声明，var声明的会成为window对象的属性，let则不会"></a>4. 全局声明，var声明的会成为window对象的属性，let则不会</h2><p>直接上代码，不罗嗦：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">23</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);   <span class="comment">// 23</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">32</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>结论很明显，var声明的变量会挂载到全局对象window上，而let声明的变量则不会挂载在window对象上。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>npm、yarn下载包的源地址查看与设置成国内淘宝镜像的地址</title>
    <url>/2021/12/13/npm%E3%80%81yarn%E4%B8%8B%E8%BD%BD%E5%8C%85%E7%9A%84%E6%BA%90%E5%9C%B0%E5%9D%80%E6%9F%A5%E7%9C%8B%E4%B8%8E%E8%AE%BE%E7%BD%AE%E6%88%90%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E7%9A%84%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="1-查询npm，yarn等下载包的源地址"><a href="#1-查询npm，yarn等下载包的源地址" class="headerlink" title="1.查询npm，yarn等下载包的源地址"></a>1.查询npm，yarn等下载包的源地址</h2><p><code>npm config get registry</code></p>
<p><code>yarn config get registry</code></p>
<h2 id="2-设置成国内淘宝镜像的地址（加快下载第三方包的速度，服务器在国内，超快的）"><a href="#2-设置成国内淘宝镜像的地址（加快下载第三方包的速度，服务器在国内，超快的）" class="headerlink" title="2.设置成国内淘宝镜像的地址（加快下载第三方包的速度，服务器在国内，超快的）"></a>2.设置成国内淘宝镜像的地址（加快下载第三方包的速度，服务器在国内，超快的）</h2><p><code>npm config set registry https://registry.npmmirror.com</code></p>
<p><code>yarn config set registry https://registry.npmmirror.com</code></p>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>node爬虫入门</title>
    <url>/2022/01/01/node%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-爬取接口数据"><a href="#1-爬取接口数据" class="headerlink" title="1. 爬取接口数据"></a>1. 爬取接口数据</h2><p>使用http，axios等爬取api接口数据，for example：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">;(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(<span class="string">&#x27;https://api.juejin.cn/user_api/v1/author/recommend?category_id=&amp;cursor=0&amp;limit=20&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data, <span class="number">996</span>)</span><br><span class="line">  fs.writeFileSync(<span class="string">&#x27;./data.json&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="2-爬取html页面"><a href="#2-爬取html页面" class="headerlink" title="2. 爬取html页面"></a>2. 爬取html页面</h2><p>有些页面是服务端渲染的，很多数据并不是通过api接口获取的，此时爬虫api接口是无法拿到想要的数据的，此时可以使用request、crawl等爬取整个html页面，然后再从中寻找想要的数据，for example：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;http://www.foshan.gov.cn/&#x27;</span></span><br><span class="line">request(url, <span class="function">(<span class="params">err, res, body</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(body)</span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;index.html&#x27;</span>, body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-puppeteer爬取数据"><a href="#3-puppeteer爬取数据" class="headerlink" title="3. puppeteer爬取数据"></a>3. puppeteer爬取数据</h2><p>Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the <a href="https://chromedevtools.github.io/devtools-protocol/">DevTools Protocol</a>. Puppeteer runs <a href="https://developers.google.com/web/updates/2017/04/headless-chrome">headless</a> by default, but can be configured to run full (non-headless) Chrome or Chromium.</p>
<h3 id="a-打开某一页面"><a href="#a-打开某一页面" class="headerlink" title="a. 打开某一页面"></a>a. 打开某一页面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">;(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        <span class="attr">headless</span>: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">&#x27;#kw&#x27;</span>, <span class="string">&#x27;Amazon&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#su&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitForTimeout(<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#\\31  &gt; h3 &gt; a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="b-获取页面数据"><a href="#b-获取页面数据" class="headerlink" title="b. 获取页面数据"></a>b. 获取页面数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> (puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="comment">// 进入页面</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://music.163.com/#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击搜索框拟人输入 忘情水</span></span><br><span class="line">    <span class="keyword">const</span> musicName = <span class="string">&#x27;忘情水&#x27;</span>;</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">&#x27;.txt.j-flag&#x27;</span>, musicName, &#123;<span class="attr">delay</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回车</span></span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取歌曲列表的 iframe</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForTimeout(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">let</span> iframe = <span class="keyword">await</span> page.frames().find(<span class="function"><span class="params">f</span> =&gt;</span> f.name() === <span class="string">&#x27;contentFrame&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> SONG_LS_SELECTOR = <span class="keyword">await</span> iframe.$(<span class="string">&#x27;.srchsongst&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取歌曲 忘情水 的地址</span></span><br><span class="line">    <span class="keyword">const</span> selectedSongHref = <span class="keyword">await</span> iframe.evaluate(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.childNodes, <span class="number">77</span>)</span><br><span class="line">        <span class="keyword">const</span> songList = <span class="built_in">Array</span>.from(e.childNodes);</span><br><span class="line">        <span class="keyword">const</span> idx = songList.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v.childNodes[<span class="number">1</span>].innerText.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) === <span class="string">&#x27;忘情水(Live)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> songList[idx].childNodes[<span class="number">1</span>].firstChild.firstChild.firstChild.href;</span><br><span class="line">    &#125;, SONG_LS_SELECTOR);</span><br><span class="line">    <span class="built_in">console</span>.log(selectedSongHref, <span class="number">996</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入歌曲页面</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(selectedSongHref);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取歌曲页面嵌套的 iframe</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForTimeout(<span class="number">2000</span>);</span><br><span class="line">    iframe = <span class="keyword">await</span> page.frames().find(<span class="function"><span class="params">f</span> =&gt;</span> f.name() === <span class="string">&#x27;contentFrame&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击 展开按钮</span></span><br><span class="line">    <span class="keyword">const</span> unfoldButton = <span class="keyword">await</span> iframe.$(<span class="string">&#x27;#flag_ctrl&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> unfoldButton.click();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取歌词</span></span><br><span class="line">    <span class="keyword">const</span> LYRIC_SELECTOR = <span class="keyword">await</span> iframe.$(<span class="string">&#x27;#lyric-content&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> lyricCtn = <span class="keyword">await</span> iframe.evaluate(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e.innerText;</span><br><span class="line">    &#125;, LYRIC_SELECTOR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(lyricCtn, <span class="string">&#x27;lyricCtn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截图</span></span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;puppeteer/忘情水-刘德华.png&#x27;</span>,</span><br><span class="line">        <span class="attr">fullPage</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="keyword">let</span> writerStream = fs.createWriteStream(<span class="string">&#x27;puppeteer/忘情水.txt&#x27;</span>);</span><br><span class="line">    writerStream.write(lyricCtn, <span class="string">&#x27;UTF8&#x27;</span>);</span><br><span class="line">    writerStream.end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取评论数量</span></span><br><span class="line">    <span class="keyword">const</span> commentCount = <span class="keyword">await</span> iframe.$eval(<span class="string">&#x27;.sub.s-fc3&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.innerText);</span><br><span class="line">    <span class="built_in">console</span>.log(commentCount, <span class="string">&#x27;commentCount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取评论</span></span><br><span class="line">    <span class="keyword">const</span> commentList = <span class="keyword">await</span> iframe.$$eval(<span class="string">&#x27;.itm .cnt.f-brk&#x27;</span>, <span class="function"><span class="params">elements</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctn = elements.map(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v.innerText.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;\r\n&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ctn;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(commentList, <span class="string">&#x27;commentList&#x27;</span>);</span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;puppeteer/评论.txt&#x27;</span>, commentList)</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-cheerio—node端操作dom"><a href="#4-cheerio—node端操作dom" class="headerlink" title="4. cheerio—node端操作dom"></a>4. cheerio—node端操作dom</h2><p>cheerio是jquery核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对DOM进行操作的地方，俗称node端的jquery。</p>
<p>使用cheerio对Amazon的某一产品进行数据抓取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.amazon.cn/s?k=longines&amp;__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;ref=nb_sb_noss&#x27;</span></span><br><span class="line">request(url, <span class="function">(<span class="params">err, res, body</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;cheerio/index.html&#x27;</span>, body)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(body)</span><br><span class="line"></span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;cheerio/test.html&#x27;</span>, $(<span class="string">&#x27;#search &gt; div.s-desktop-width-max.s-desktop-content.sg-row &gt; div.sg-col-16-of-20.sg-col.sg-col-8-of-12.sg-col-12-of-16 &gt; div &gt; span:nth-child(4) &gt; div.s-main-slot.s-result-list.s-search-results.sg-row&#x27;</span>).children())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj = []</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="string">&#x27;.a-section.a-spacing-medium&#x27;</span>).length, <span class="number">77</span>)</span><br><span class="line">    $(<span class="string">&#x27;.a-section.a-spacing-medium&#x27;</span>).each(<span class="function">(<span class="params">i, item</span>) =&gt;</span> &#123;</span><br><span class="line">        obj[i] = &#123;&#125;</span><br><span class="line">        obj[i].picSrc = $(<span class="string">&#x27;img&#x27;</span>, item).attr(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">        obj[i].price = $(<span class="string">&#x27;.a-offscreen&#x27;</span>, item).text()</span><br><span class="line">        obj[i].title = $(<span class="string">&#x27;.a-size-base-plus.a-color-base.a-text-normal&#x27;</span>, item).text()</span><br><span class="line">    &#125;)</span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;cheerio/data.json&#x27;</span>, <span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Webrambler/crawler-test">代码仓库地址</a>，欢迎大家互follow！</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json 里 devDependencies和dependencies的区别</title>
    <url>/2021/12/12/package-json-%E9%87%8C-devDependencies%E5%92%8Cdependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>我们在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：</p>
<p>npm i 【包名】 –save-dev</p>
<p>npm i 【包名】 –save</p>
<p>在 package.json 文件里面提现出来的区别就是：</p>
<p>使用 npm i 【包名】 –save-dev 安装的包，会被写入到 devDependencies 对象里面去；</p>
<p>而使用 npm i 【包名】 –save 安装的包，则被写入到 dependencies 对象里面去。</p>
<p>那么 package.json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？</p>
<p>devDependencies  里面的插件(比如各种loader，babel全家桶及各种webpack的插件等)只用于开发环境，不用于生产环境，因此不需要打包；而 dependencies  是需要发布到生产环境的，是要打包的(比如vue，vue-router，vuex，axios等)。</p>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>postcss简介</title>
    <url>/2022/01/22/postcss%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>css预处理器在目前的开发中是很受欢迎的，但是它们也有一些缺点。在今天的介绍中，我们将探讨postcss的优势以及它是如何工作的，还有其一些丰富而且实用的插件。</p>
<h1 id="css预处理器的价值和局限性"><a href="#css预处理器的价值和局限性" class="headerlink" title="css预处理器的价值和局限性"></a>css预处理器的价值和局限性</h1><p>大多数CSS开发人员都非常熟悉css预处理器，像sass、less、stylus等，以及伴随着这些预处理器出现的一些概念，比如file partials, nesting, variables 和 mixins等。随着css的发展，预处理器的一些功能正在渐渐的被原生css所实现，但是还有大量非常实用的功能对于开发者开发大型项目以及维护保持代码的一致性方面是及其有用的。</p>
<p>你可能很难想象没有 CSS 预处理器的生活，但它也有缺点：</p>
<ul>
<li><strong>预处理器不可扩展或受限。</strong>大多数预处理器都是一个黑匣子，它为您提供一组特定的受支持功能。可以编写自定义功能，但超出该工具范围的功能仍然是不可能的——例如将 SVG 内联为背景图像。<br>同样，您不能阻止开发人员使用您宁愿避免使用的选项，例如@extend深度嵌套。Linting 可以提供帮助，但它不会阻止预处理器编译有效文件。</li>
<li><strong>预处理器提供自己的语法。</strong>预处理器代码可能类似于 CSS，但没有浏览器可以原生解析使用预处理器编写的文件。他们的语法都不同，如果您的工具更改或不可用，您的代码将需要更新以使其可用。</li>
</ul>
<p>好处超过了这些风险，但还有另一种选择……</p>
<h1 id="什么是-PostCSS？"><a href="#什么是-PostCSS？" class="headerlink" title="什么是 PostCSS？"></a>什么是 PostCSS？</h1><p>PostCSS<a href="https://github.com/postcss/postcss">不是一个预处理器</a>（尽管它可以表现得像一个）。这是一个 Node.js 工具，它采用有效的 CSS 并对其进行增强。即使是那些使用 Sass、Less 或 Stylus 的人，也经常在初始 CSS 编译之后运行 PostCSS 步骤。您可能遇到过 PostCSS <a href="https://github.com/postcss/autoprefixer">Autoprefixer 插件</a>，它会自动将-webkit、-moz和-msvendor 前缀添加到需要它们的 CSS 属性中。</p>
<p>就其本身而言，PostCSS 什么都不做。它是一个解析器，它对 CSS 代码进行标记以创建抽象语法树。插件可以处理此树并相应地更新属性。一旦所有插件都完成了工作，PostCSS 会将所有内容重新格式化为字符串并输出到 CSS 文件。</p>
<p>大约有 <a href="https://github.com/postcss/postcss/blob/main/docs/plugins.md">350 个插件</a>可用，大多数都执行单一任务，例如<a href="https://github.com/postcss/postcss-import">内联<code>@import</code>声明</a>、<a href="https://github.com/postcss/postcss-calc">简化<code>calc()</code>函数</a>、<a href="https://github.com/borodean/postcss-assets">处理图像资产</a>、<a href="https://github.com/stylelint/stylelint" title="语法检查">语法检查</a>、<a href="https://cssnano.co/" title="缩小">缩小</a>等。PostCSS<a href="https://www.postcss.parts/">插件目录</a>中提供了更加用户友好的插件搜索。</p>
<p>PostCSS 的好处包括：</p>
<ul>
<li><strong>您从标准 CSS 开始。</strong>PostCSS 之于 CSS 就像Babel之于 JavaScript。它可以采用适用于最近浏览器的标准样式表并输出适用于任何地方的 CSS——例如，将较新的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inset"><code>inset</code>属性</a>转换回<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性。随着时间的推移，随着更多浏览器支持<code>inset</code>。<br>诚然，一些插件允许您解析不是标准 CSS 的类似预处理器的语法，但您不必使用它们。</li>
<li><strong>使用您需要的插件和功能。</strong>PostCSS 是可配置的，你可以采用你需要的插件。例如，您可以支持file partials和嵌套，但不允许 Sass 中可用的变量、循环、混合、映射和其他功能。</li>
<li><strong>为每个项目提供自定义配置。</strong>单个项目配置可以增强或减少其他地方使用的插件集。这些选项比任何预处理器都要多样化。</li>
<li><strong>编写您自己的 PostCSS 插件。</strong>广泛的插件可用于扩展语法、解析未来属性、添加回退、优化代码、处理颜色、图像、字体，甚至用其他语言（如西班牙语和俄语）编写 CSS 。<br>万一你找不到你需要的东西，你可以用 JavaScript编写你自己的PostCSS 插件。</li>
<li><strong>您可能已经在使用 PostCSS。</strong>如果您已经在运行诸如 AutoPrefixer 之类的 PostCSS 插件，您可能能够删除您的预处理器依赖项。PostCSS 不一定比使用预处理器更快或更轻量级，但它可以在一个步骤中处理所有 CSS 处理。</li>
</ul>
<h1 id="安装-PostCSS"><a href="#安装-PostCSS" class="headerlink" title="安装 PostCSS"></a>安装 PostCSS</h1><p>PostCSS 需要Node.js，但本教程演示了如何从任何文件夹安装和运行 PostCSS——即使是那些不是 Node.js 项目的文件夹。您还可以使用 <a href="https://github.com/postcss/postcss#usage">webpack 、Parcel、Gulp.js 和其他工具中</a>的 PostCSS ，但我们将坚持使用命令行。</p>
<p>通过运行以下命令在您的系统上全局安装 PostCSS：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g postcss-cli</span><br></pre></td></tr></table></figure>
<p>通过输入以下内容确保其正常工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">postcss --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h1 id="安装你的第一个-PostCSS-插件"><a href="#安装你的第一个-PostCSS-插件" class="headerlink" title="安装你的第一个 PostCSS 插件"></a>安装你的第一个 PostCSS 插件</h1><p>你至少需要一个插件来做任何实际的事情。PostCSS<a href="https://github.com/postcss/postcss-import" title="导入">导入</a>插件是一个不错的选择，它内联所有<code>@import</code>声明并将您的 CSS 合并到一个文件中。像这样全局安装它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g postcss-import</span><br></pre></td></tr></table></figure>
<p>要测试此插件，请打开或创建一个新的项目文件夹，例如<code>cssproject</code>，然后<code>src</code>为您的源文件创建一个子文件夹。创建一个<code>main.css</code>文件以加载所有部分：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/main.css */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;_reset&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;_elements&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后<code>_reset.css</code>在同一文件夹中创建一个文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/reset.css */</span></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟着这个<code>_elements.css</code>文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/elements.css */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过传递输入 CSS 文件、插件列表<code>--use</code>和<code>--output</code>文件名，从项目的根文件夹运行 PostCSS：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --use postcss-import --output ./styles.css</span><br></pre></td></tr></table></figure>
<p>如果您没有任何错误，以下代码将输出到<code>styles.css</code>项目根目录中的新文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/main.css */</span></span><br><span class="line"><span class="comment">/* src/reset.css */</span></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* src/elements.css */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* sourceMappingURL=data:application/json;base64,...</span></span><br></pre></td></tr></table></figure>
<p><em>注意PostCSS可以在任何地方输出CSS文件，但输出文件夹必须存在；它不会为您创建文件夹结构。</em></p>
<h1 id="启用和禁用源映射"><a href="#启用和禁用源映射" class="headerlink" title="启用和禁用源映射"></a>启用和禁用源映射</h1><p>默认情况下会输出内联源映射。在 HTML 页面中使用编译后的 CSS 文件时，在浏览器的开发人员工具中检查它会显示原始<code>src</code>文件和行。例如，查看<code>&lt;body&gt;</code>样式将突出显示<code>src/_elements.css</code>第 2 行而不是<code>styles.css</code>第 8 行。</p>
<p>您可以通过在命令中添加<code>--map</code>（或<code>-m</code>）开关来创建外部源映射。postcss除了 CSS 文件更干净并且浏览器不需要加载源映射之外，几乎没有什么好处，除非开发者工具是打开的。</p>
<p>您可以使用 删除源映射<code>--no-map</code>。在为生产部署输出 CSS 文件时始终使用此选项。</p>
<h1 id="安装和使用-AutoPrefixer-插件"><a href="#安装和使用-AutoPrefixer-插件" class="headerlink" title="安装和使用 AutoPrefixer 插件"></a>安装和使用 AutoPrefixer 插件</h1><p><code>Autoprefixer</code>插件通常是开发人员第一次接触 PostCSS 。它根据浏览器使用情况和<a href="https://caniuse.com/" title="caniuse.com">caniuse.com</a>定义的规则添加供应商前缀。供应商前缀在现代浏览器中使用较少，这些浏览器将实验性功能隐藏在标志后面。但是，仍有一些属性，例如<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-select"><code>user-select</code></a> 需要<code>-webkit-</code>、<code>-moz-</code>和<code>-ms-</code>前缀。</p>
<p>使用以下命令全局安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g autoprefixer</span><br></pre></td></tr></table></figure>
<p>然后将其作为命令中的另一个<code>--use</code>选项引用postcss：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --use postcss-import --use autoprefixer --output ./styles.css</span><br></pre></td></tr></table></figure>
<p>检查第 11 行的声明<code>styles.css</code>以查看供应商前缀属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AutoPrefixer 使用<a href="https://github.com/browserslist/browserslist" title="browserslist">browserslist</a>模块来确定要添加哪些浏览器前缀。默认值为：</p>
<ul>
<li><code>&gt; 0.5%</code>：市场份额至少为 0.5% 的浏览器</li>
<li><code>last 2 versions</code>：这些浏览器的最后两个版本</li>
<li><code>Firefox ESR</code>: 包括 Firefox 扩展支持版本</li>
<li><code>not dead</code>: 任何未停产的浏览器</li>
</ul>
<p>您可以通过创建.browserslistrc文件来更改这些默认值。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 2%</span></span><br></pre></td></tr></table></figure>
<p>或者，您可以在 Node.js 项目中添加一个”browserslist”数组。package.json例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;&gt; 2%&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="使用-cssnano-缩小-CSS"><a href="#使用-cssnano-缩小-CSS" class="headerlink" title="使用 cssnano 缩小 CSS"></a>使用 cssnano 缩小 CSS</h1><p><a href="https://cssnano.co/" title="cssnano">cssnano</a> 通过去除空格、注释和其他不必要的字符来缩小 CSS。结果会有所不同，但您可以预期文件减少 30%，您可以将其部署到生产服务器以获得更好的网页性能。</p>
<p>全局安装 cssnano：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cssnano</span><br></pre></td></tr></table></figure>
<p>然后将其添加到您的postcss命令中。我们还将包括<code>--no-map</code>禁用源地图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --use postcss-import --use autoprefixer --use cssnano --no-map --output ./styles.css</span><br></pre></td></tr></table></figure>
<p>这会将 CSS 文件减少到 97 个字符：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>&#125;<span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:sans-serif&#125;<span class="selector-tag">label</span>&#123;-webkit-user-select:none;user-select:none&#125;</span><br></pre></td></tr></table></figure>
<h1 id="源文件更改时自动构建"><a href="#源文件更改时自动构建" class="headerlink" title="源文件更改时自动构建"></a>源文件更改时自动构建</h1><p><code>--watch</code>当任何源文件发生更改时，PostCSS选项会自动构建您的 CSS 文件。您可能还想添加在<code>--verbose</code>构建发生时报告的开关：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --use postcss-import --use autoprefixer --use cssnano --no-map --output ./styles.css --watch --verbose</span><br></pre></td></tr></table></figure>
<p>您的终端将显示<code>Waiting for file changes</code>. 对任何文件进行更改并<code>styles.css</code>重新构建。PostCSS 也会报告任何问题，例如语法错误。</p>
<p>要完成，请按<code>Ctrl + C</code>或<code>Cmd + C</code>在终端中。</p>
<h1 id="创建-PostCSS-配置文件"><a href="#创建-PostCSS-配置文件" class="headerlink" title="创建 PostCSS 配置文件"></a>创建 PostCSS 配置文件</h1><p>随着您添加更多插件和选项，该postcss命令将变得冗长而繁琐。您可以创建一个 JavaScript 配置文件，该文件定义了所有选项，并且可以从逻辑上确定它是在开发环境中运行还是在生产环境中运行。</p>
<p><code>postcss.config.cjs</code>在项目文件夹的根目录中创建一个名为的配置文件。请注意以下几点：</p>
<p>您可以将文件放在另一个文件夹中，但您需要<code>--config &lt;dir&gt;</code>在运行时指定postcss<br>您可以<code>postcss.config.js</code>用作文件名，但 PostCSS 可能在已”type”: “module”设置的Node.js 项目中失败package.json<br>将以下代码添加到<code>postcss.config.cjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PostCSS configruation</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">cfg</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> devMode = (cfg.env === <span class="string">&#x27;development&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">map</span>: devMode ? <span class="string">&#x27;inline&#x27;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">&#x27;postcss-import&#x27;</span>)(),</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(),</span><br><span class="line">      devMode ? <span class="literal">null</span> : <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>)()</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PostCSS 传递一个<code>cfg</code>包含命令行选项的对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">cwd</span>: <span class="string">&#x27;/home/yourname/cssproject&#x27;</span>,</span><br><span class="line">  <span class="attr">env</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">map</span>: &#123; <span class="attr">inline</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">parser</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">syntax</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">stringifier</span>: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">file</span>: &#123;</span><br><span class="line">    <span class="attr">dirname</span>: <span class="string">&#x27;/home/yourname/cssproject/src&#x27;</span>,</span><br><span class="line">    <span class="attr">basename</span>: <span class="string">&#x27;main.css&#x27;</span>,</span><br><span class="line">    <span class="attr">extname</span>: <span class="string">&#x27;.css&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块必须返回一个带有可选属性的对象：</p>
<ul>
<li><code>map</code>：源地图设置</li>
<li><code>parser</code>: 是否使用非 CSS 语法解析器（如scss插件）</li>
<li><code>plugins</code>：要按指定顺序处理的插件和配置数组</li>
</ul>
<p>上面的代码检测postcss命令是否有<code>--env</code>选项。这是设置<code>NODE_ENV</code>环境变量的快捷方式。要在开发模式下编译 CSS，请运行postcss并<code>--env development</code>（可选）设置<code>--watch --verbose</code>. 这将创建一个内联源映射并且不会缩小输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --output ./styles.css --env development --watch --verbose</span><br></pre></td></tr></table></figure>
<p>要在生产模式下运行并在没有源映射的情况下编译缩小的 CSS，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss ./src/main.css --output ./styles.css</span><br></pre></td></tr></table></figure>
<p>理想情况下，您可以将它们作为终端或npm脚本运行，以进一步减少打字工作。</p>
<h1 id="PostCSS-进展"><a href="#PostCSS-进展" class="headerlink" title="PostCSS 进展"></a>PostCSS 进展</h1><p>您现在了解了 PostCSS 的基础知识。增强功能是添加和配置更多插件的问题。投入一些时间，您很快就会拥有一个可以适应任何 Web 项目的工作流程。</p>
<p>关于如何使用 PostCSS 作为<a href="https://www.sitepoint.com/postcss-sass-configurable-alternative/">Sass 的可配置替代品</a>的教程提供了更多配置示例和插件选项。</p>
<p><strong>更多链接：</strong></p>
<ul>
<li><a href="https://postcss.org/">PostCSS主页</a></li>
<li><a href="https://github.com/postcss/postcss-cli">PostCSS CLI</a></li>
<li><a href="https://github.com/postcss/postcss/blob/main/docs/plugins.md">PostCSS的插件列表</a></li>
<li><a href="https://www.postcss.parts/">PostCSS的可搜索插件目录</a></li>
<li><a href="https://www.npmjs.com/search?q=keywords:postcss">npmjs.com 上用于 PostCSS 的插件</a></li>
<li><a href="https://github.com/postcss/postcss/blob/main/docs/writing-a-plugin.md">为 PostCSS编写插件</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>react+typescript正确的开发姿势之正确使用hooks之useReducer</title>
    <url>/2022/01/15/react-typescript%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%A7%BF%E5%8A%BF%E4%B9%8B%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hooks%E4%B9%8BuseReducer/</url>
    <content><![CDATA[<h2 id="在react-typescript项目中正确使用useReducer"><a href="#在react-typescript项目中正确使用useReducer" class="headerlink" title="在react + typescript项目中正确使用useReducer"></a>在react + typescript项目中正确使用useReducer</h2><p>我们在Home页面增加一个组件Counter，用来保存一个数值count，来记录点击按钮的次数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">type StateType = &#123;</span><br><span class="line">    <span class="attr">count</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ActionType = &#123;</span><br><span class="line">    <span class="attr">type</span>: string;</span><br><span class="line">    payload: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state: StateType, action: ActionType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + action.payload&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - action.payload&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(countReducer, initialState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">            <span class="attr">payload</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _decrement = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>,</span><br><span class="line">            <span class="attr">payload</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your count is &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_increment&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_decrement&#125;</span>&gt;</span>decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Home页面使用，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&quot;../components/Counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是Home页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们现在新增一种action的type，为重置按钮reset，即<code>&lt;button onClick=&#123;_reset&#125;&gt;reset&lt;/button&gt;</code>；<br>reducer函数也要做出相应的改变，新增一个type时的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">	<span class="keyword">return</span> initialState</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>相应的reset函数为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _reset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	dispatch(&#123;</span><br><span class="line">		<span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写之后会有个问题，就是我们在调用<code>_reset</code>函数时会报错，因为我们只传入了一个type参数，没有传payload，ts编译器会告诉我们这里类型不匹配，但是我们这个函数的功能是重置，也就是根本就不需要使用到参数payload，那么怎么办呢？我们这样可以来写ActionType：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type UpdateActionType = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> | <span class="string">&#x27;decrement&#x27;</span>;</span><br><span class="line">    payload: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ResetActionType = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ActionType = UpdateActionType | ResetActionType;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们在增加、减少和重置的时候都会去匹配对应的类型，ts编译器也可以愉快的玩耍了。<br>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">type StateType = &#123;</span><br><span class="line">    <span class="attr">count</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type UpdateActionType = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> | <span class="string">&#x27;decrement&#x27;</span>;</span><br><span class="line">    payload: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ResetActionType = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ActionType = UpdateActionType | ResetActionType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state: StateType, action: ActionType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + action.payload&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - action.payload&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> initialState</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(countReducer, initialState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">            <span class="attr">payload</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _decrement = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>,</span><br><span class="line">            <span class="attr">payload</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _reset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your count is &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_increment&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_decrement&#125;</span>&gt;</span>decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_reset&#125;</span>&gt;</span>reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码地址及文件路径"><a href="#代码地址及文件路径" class="headerlink" title="代码地址及文件路径"></a>代码地址及文件路径</h2><p>注：<br>本文代码github仓库地址：<a href="https://github.com/webRambler/react-ts-practice" title="ts中正确使用useState">ts中正确使用useReducer</a><br>文件路径：<code>src/components/Counter.tsx</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react+typescript正确的开发姿势之函数式组件</title>
    <url>/2022/01/12/react-typescript%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%A7%BF%E5%8A%BF%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="函数式组件声明"><a href="#函数式组件声明" class="headerlink" title="函数式组件声明"></a>函数式组件声明</h1><p>使用typescript正确的声明react函数式组件是通常有三种：直接声明、React.FC 和 PropsWithChildren。</p>
<h2 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h2><p>直接声明函数式组件的code如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type HomePropsType = &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    age: number;</span><br><span class="line">	children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">(<span class="params">props: HomePropsType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            这是home组件</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-React-FC-声明"><a href="#使用-React-FC-声明" class="headerlink" title="使用 React.FC 声明"></a>使用 React.FC 声明</h2><p>话不多说，直接上code：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type HomePropsType = &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home: FC&lt;HomePropsType&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            这是home组件</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此种方式是通过React.FunctionComponent（FC是FunctionComponent的缩写）结合typescript中的泛型来定义函数式组件，这样声明的好处有以下几个：</p>
<ul>
<li>props的类型声明（本例中的HomePropsType）中无需声明children属性，React.FC会自动为props添加这个属性类型；</li>
<li>React.FC对静态属性：displayName、propTypes、defaultProps提供了类型检查和自动补全；</li>
<li>React.FC显式地定义了返回类型，其他声明方式的返回类型是隐式推导的；<h2 id="使用PropsWithChildren声明"><a href="#使用PropsWithChildren声明" class="headerlink" title="使用PropsWithChildren声明"></a>使用PropsWithChildren声明</h2>这种方式可以为你省去频繁定义 children 的类型，自动设置 children 类型为 ReactNode:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type HomePropsType = React.PropsWithChildren&lt;&#123; <span class="attr">name</span>: string; age: number; &#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">(<span class="params">props: HomePropsType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            这是home组件</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react全局状态管理react-redux</title>
    <url>/2021/12/12/react%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86react-redux/</url>
    <content><![CDATA[<p>简言之，通过react-redux提供的connect方法将UI组件同store连接起来，connect方法可以接受两个参数，第一个为mapStateToProps（接受两个参数，state，ownProps），用于UI组件的输入逻辑，此建立了从外部的数据（即store中的state对象）到UI组件的props的一个映射；第二个参数为mapDispatchToProps（接受两个参数，dispatch，ownProps），用于UI组件的输出逻辑，即用户发出的动作如何变为 Action 对象，从 UI 组件传出去，从而影响外部数据state。</p>
<p>State 的变化必须是 View 导致的，Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
<p>Action 是一个对象。其中的type属性是必须的，表示 Action 的名称，其他属性可以自由设置。</p>
<p>对象store的方法dispath用于派发action，store.dispatch(action)是 View 发出 Action 的唯一方法。</p>
<p>通过dispath派发的action会触发reducer，reducer执行会返回一个新的state，此时state改变了。</p>
<p>state的改变又会通过mapStateToProps函数传入UI组件的props，UI组件的Props改变又会触发render函数，从而更新UI组件。</p>
<p>以上就是redux大致的工作流程。欢迎大神们评论批评指正。（action，reducer等基本概念参见阮一峰老师的博客）</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react项目配置react-hot-loader实现模块热更新</title>
    <url>/2021/12/18/react%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEreact-hot-loader%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们来聊一聊react的模块热更新，熟悉react的同学都知道，使用官方的脚手架，当我们改动页面时，整个页面会被刷新，那我们当然希望页面只刷新我们改动的部分而不是刷新整个页面，那么怎么做到如此呢？千呼万唤始出来，react-hot-loader就是来完成这个伟大的使命的。</p>
<h2 id="1-安装react-hot-loader"><a href="#1-安装react-hot-loader" class="headerlink" title="1. 安装react-hot-loader"></a>1. 安装react-hot-loader</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i react-hot-loader --save</span><br></pre></td></tr></table></figure>

<h2 id="2-在开发环境下添加入口"><a href="#2-在开发环境下添加入口" class="headerlink" title="2. 在开发环境下添加入口"></a>2. 在开发环境下添加入口</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="attr">entry</span>: [</span><br><span class="line">      isEnvDevelopment &amp;&amp; <span class="string">&#x27;react-hot-loader/patch&#x27;</span>,</span><br><span class="line">      <span class="comment">// Include an alternative client for WebpackDevServer. A client&#x27;s job is to</span></span><br><span class="line">      <span class="comment">// connect to WebpackDevServer by a socket and get notified about changes.</span></span><br><span class="line">      <span class="comment">// When you save a file, the client will either apply hot updates (in case</span></span><br><span class="line">      <span class="comment">// of CSS changes), or refresh the page (in case of JS changes). When you</span></span><br><span class="line">      <span class="comment">// make a syntax error, this client will display a syntax error overlay.</span></span><br><span class="line">      <span class="comment">// Note: instead of the default WebpackDevServer client, we use a custom one</span></span><br><span class="line">      <span class="comment">// to bring better experience for Create React App users. You can replace</span></span><br><span class="line">      <span class="comment">// the line below with these two lines if you prefer the stock client:</span></span><br><span class="line">      <span class="comment">// require.resolve(&#x27;webpack-dev-server/client&#x27;) + &#x27;?/&#x27;,</span></span><br><span class="line">      <span class="comment">// require.resolve(&#x27;webpack/hot/dev-server&#x27;),</span></span><br><span class="line">      isEnvDevelopment &amp;&amp;</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;react-dev-utils/webpackHotDevClient&#x27;</span>),</span><br><span class="line">      <span class="comment">// Finally, this is your app&#x27;s code:</span></span><br><span class="line">      paths.appIndexJs,</span><br><span class="line">      <span class="comment">// We include the app code last so that if there is a runtime error during</span></span><br><span class="line">      <span class="comment">// initialization, it doesn&#x27;t blow up the WebpackDevServer client, and</span></span><br><span class="line">      <span class="comment">// changing JS code would still trigger a refresh.</span></span><br><span class="line">    ].filter(<span class="built_in">Boolean</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上，entry的第一行即为我们添加的内容。</p>
<h2 id="3-在开发环境下配置babel插件"><a href="#3-在开发环境下配置babel插件" class="headerlink" title="3. 在开发环境下配置babel插件"></a>3. 在开发环境下配置babel插件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,</span><br><span class="line">        include: paths.appSrc,</span><br><span class="line">        <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-loader&#x27;</span>),</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">customize</span>: <span class="built_in">require</span>.resolve(</span><br><span class="line">            <span class="string">&#x27;babel-preset-react-app/webpack-overrides&#x27;</span></span><br><span class="line">          ),</span><br><span class="line">          </span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            isEnvDevelopment &amp;&amp; <span class="string">&#x27;react-hot-loader/babel&#x27;</span>,</span><br><span class="line">            [</span><br><span class="line">              <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-plugin-named-asset-import&#x27;</span>),</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loaderMap</span>: &#123;</span><br><span class="line">                  <span class="attr">svg</span>: &#123;</span><br><span class="line">                    <span class="attr">ReactComponent</span>: <span class="string">&#x27;@svgr/webpack?-svgo,+ref![path]&#x27;</span>,</span><br><span class="line">                  &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">          <span class="comment">// This is a feature of `babel-loader` for webpack (not Babel itself).</span></span><br><span class="line">          <span class="comment">// It enables caching results in ./node_modules/.cache/babel-loader/</span></span><br><span class="line">          <span class="comment">// directory for faster rebuilds.</span></span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">cacheCompression</span>: isEnvProduction,</span><br><span class="line">          <span class="attr">compact</span>: isEnvProduction,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>
<p>如上，plugins配置的第一行：<code>isEnvDevelopment &amp;&amp; &#39;react-hot-loader/babel&#39;</code>，即为我们添加的代码，如果配置在.babelrc文件中，则写在.babelrc的plugins配置中。</p>
<h2 id="4-plugins中添加依赖的-HotModuleReplacement-插件"><a href="#4-plugins中添加依赖的-HotModuleReplacement-插件" class="headerlink" title="4. plugins中添加依赖的 HotModuleReplacement 插件"></a>4. plugins中添加依赖的 HotModuleReplacement 插件</h2><p>一般情况下，脚手架初始化的项目此步骤已经满足，无需再改动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//设置这里</span></span><br><span class="line">        ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="5-设置-devServer-的-hot-为-true"><a href="#5-设置-devServer-的-hot-为-true" class="headerlink" title="5. 设置 devServer 的 hot 为 true"></a>5. 设置 devServer 的 hot 为 true</h2><p>一般情况下，脚手架初始化的项目此步骤已经满足，无需再改动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,  <span class="comment">//设置这里</span></span><br><span class="line">       ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="6-在项目主入口文件中进行修改"><a href="#6-在项目主入口文件中进行修改" class="headerlink" title="6. 在项目主入口文件中进行修改"></a>6. 在项目主入口文件中进行修改</h2><p>首先，从 react-hot-loader 导入 AppContainer 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">&#x27;react-hot-loader&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，改写 render 方法：</p>
<p>原 render 为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改之后为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">AppContainer</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">AppContainer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,  </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，执行render函数，继而再写模块热更新时的处理代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render(App);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./App&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//因为在App里使用的是export default语法，这里使用的是require,默认不会加载default的，所以需要手动加上</span></span><br><span class="line">    <span class="keyword">const</span> NextApp = <span class="built_in">require</span>(<span class="string">&#x27;./App&#x27;</span>).default;</span><br><span class="line">    <span class="comment">// 重新渲染到 document 里面</span></span><br><span class="line">    render(NextApp);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的主入口文件为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">&#x27;./serviceWorker&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">&#x27;react-hot-loader&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">AppContainer</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">AppContainer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>, </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render(App);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./App&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//因为在App里使用的是export default语法，这里使用的是require,默认不会加载default的，所以需要手动加上</span></span><br><span class="line">    <span class="keyword">const</span> NextApp = <span class="built_in">require</span>(<span class="string">&#x27;./App&#x27;</span>).default;</span><br><span class="line">    <span class="comment">// 重新渲染到 document 里面</span></span><br><span class="line">    render(NextApp);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you want your app to work offline and load faster, you can change</span></span><br><span class="line"><span class="comment">// unregister() to register() below. Note this comes with some pitfalls.</span></span><br><span class="line"><span class="comment">// Learn more about service workers: https://bit.ly/CRA-PWA</span></span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure>
<p>至此，我们就已经配置完成了react项目的模块热更新，即局部刷新而不是整个页面的刷新，如此可大大提高开发效率。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react+typescript正确的开发姿势之正确使用hooks之useState</title>
    <url>/2022/01/15/react-typescript%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%A7%BF%E5%8A%BF%E4%B9%8B%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hooks%E4%B9%8BuseState/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>要想在react + typescript 项目中正确的使用 hooks ，请务必掌握泛型的使用，关于泛型的讲解，我在上一篇博文中详细的进行了介绍，如果你还不了解 typescript 中的泛型请看上一篇：<a href="https://webrambler.github.io/2022/01/15/%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86typescript%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/" title="正确认识typescript中的泛型">正确认识typescript中的泛型</a>。</p>
<h1 id="如何结合typescript正确使用hooks"><a href="#如何结合typescript正确使用hooks" class="headerlink" title="如何结合typescript正确使用hooks"></a>如何结合typescript正确使用hooks</h1><p>在react中使用函数式组件，难免会使用到hooks，hooks赋予了函数式组件可以像 class 组件那样拥有状态的能力，那么如何结合typescript正确的使用hooks呢？</p>
<h2 id="在react-typescript项目中正确使用useState"><a href="#在react-typescript项目中正确使用useState" class="headerlink" title="在react + typescript项目中正确使用useState"></a>在react + typescript项目中正确使用useState</h2><p>如果想编写一个 Header 组件，使其具备一个登录和退出的功能，登录的时候，显示一些提示已经登录的文字，退出的时候显示欢迎的文字，那么我们很容易知道：如果使用函数式组件来编写此 Header 组件，那么就一定会用到 useState ，因为登录与否的状态是该组件自身的状态，所以就会用到hooks中的 useState 来赋予函数式组件状态。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Header.tsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isLogin, setIsLogin] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _logout = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _login = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;isLogin ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>You have logined in!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : <span class="tag">&lt;<span class="name">p</span>&gt;</span>welcome, guest!<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">            &#123;isLogin ? <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_logout&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span> : <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_login&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实在第五行<code>const [isLogin, setIsLogin] = useState(false);</code>使用useState赋予初始值false的时候，后续在调用<code>setIsLogin</code>函数时，ts 编译器就会自动推断你传入的参数是不是boolean类型的，若不是，则会报错。第五行，我们也可以进行显式的进行限制，传入泛型，就像这样<code>const [isLogin, setIsLogin] = useState&lt;boolean&gt;(false);</code></p>
<p>我们也可以把要显示的文案也抽象成为组件的一个状态，这样我们就不需要再写三元表达式了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isLogin, setIsLogin] = useState&lt;boolean&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState&lt;string&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _logout = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">false</span>);</span><br><span class="line">        setText(<span class="string">&#x27;welcome, guest!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _login = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">true</span>);</span><br><span class="line">        setText(<span class="string">&#x27;You have logined in!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; text &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;isLogin ? <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_logout&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span> : <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_login&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的函数<code>setIsLogin</code>只能传入布尔类型的值，函数<code>setText</code>只能传入 string 类型的值，传别的类型都会报错。<br>这里的两个状态比较简单，一个是布尔类型，一个是 string 类型，可能体现不出typescript的强大之处，那么我们再增加一个状态用户信息：<code>const [user, setUser] = useState&lt;UserType | null&gt;(null)</code>，完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">type UserType = &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    age: number;</span><br><span class="line">    addr: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isLogin, setIsLogin] = useState&lt;boolean&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState&lt;string&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> [user, setUser] = useState&lt;UserType | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _logout = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">false</span>);</span><br><span class="line">        setText(<span class="string">&#x27;welcome, guest!&#x27;</span>);</span><br><span class="line">        setUser(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _login = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsLogin(<span class="literal">true</span>);</span><br><span class="line">        setText(<span class="string">&#x27;You have logined in!&#x27;</span>);</span><br><span class="line">        setUser(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="attr">addr</span>: <span class="string">&#x27;深圳市南山区深圳湾河里&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; text &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>username is &#123;user?.name&#125;, user&#x27;s age is &#123;user?.age&#125;, user&#x27;s address is &#123;user?.addr&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;isLogin ? <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_logout&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span> : <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;_login&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们给useState显式的传入泛型UserType或者null，就表示我们在后续调用setUser的时候，就只能传入UserType 类型的值或者 null 类型的值，否则ts编译器就会告诉你传值错误。这样做，我们在开发过程中可以省去了很多麻烦，可维护性也更好。</p>
<h2 id="代码地址及文件路径"><a href="#代码地址及文件路径" class="headerlink" title="代码地址及文件路径"></a>代码地址及文件路径</h2><p>注：<br>本文代码github仓库地址：<a href="https://github.com/webRambler/react-ts-practice" title="ts中正确使用useState">ts中正确使用useState</a><br>文件路径：<code>src/components/Header.tsx</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>service worker实现资源离线缓存(构建离线应用)</title>
    <url>/2021/12/31/service-worker%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98-%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天我们来谈一谈ServiceWorker ,利用ServiceWorker 来进行资源的离线缓存，进而构建离线应用。谈到ServiceWorker，不得不谈一谈近些年大火的PWA。</p>
<p>PWA(Progressive Web App)翻译过来就是渐进式增强WEB应用， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。</p>
<p>再来看看MDN官方的解释：PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。</p>
<h2 id="资源离线缓存"><a href="#资源离线缓存" class="headerlink" title="资源离线缓存"></a>资源离线缓存</h2><p>此节我们将通过一个简单的demo来向大家描述如何利用ServiceWorker来进行资源的离线缓存。先看看整个demo的目录结构：</p>
<p><a href="https://img-blog.csdnimg.cn/20191009151444969.png" title="目录结构"><img src="https://img-blog.csdnimg.cn/20191009151444969.png" alt="目录结构" title="目录结构"></a></p>
<p>先来看看app.js的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sw = navigator.serviceWorker</span><br><span class="line"><span class="keyword">if</span> (sw) &#123;</span><br><span class="line">  sw.register(<span class="string">&#x27;sw.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;./&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;sw open...&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;sw error&#x27;</span>, err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sw is not supported!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们先注册serviceWorker文件，调用navigator.serviceWorker.register方法即可在应用中注册需要用到的serviceWorker文件。</p>
<p>再来看sw.js的文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheList = [</span><br><span class="line">  <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;./main.css&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;app.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;img/wk.jpg&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SW_CACHE_NAME = <span class="string">&#x27;sw-offline&#x27;</span></span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(SW_CACHE_NAME)</span><br><span class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;cahche open&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(cacheList)</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> req = event.request</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求为&#x27;</span>, req);</span><br><span class="line"></span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(req).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果我们想要增量的缓存新的请求，我们可以通过处理fetch请求的response并且添加它们到缓存中来实现(如下代码所示)</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;此处的资源需要向网络进行请求&#x27;</span>, req);</span><br><span class="line">        <span class="comment">// 克隆请求。因为请求是一个“stream”，只能用一次。但我们需要用两次，一次用来缓存，一次给浏览器抓取内容，所以需要克隆</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = req.clone();</span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(<span class="function"><span class="params">response</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否为有效的响应。basic表示同源响应，也就是说，这意味着，对第三方资产的请求不会添加到缓存。</span></span><br><span class="line">            <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span> || !response.headers.get(<span class="string">&#x27;Content-type&#x27;</span>).match(<span class="regexp">/img/</span>)) &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同request，response是一个“stream”，只能用一次，但我们需要用两次，一次用来缓存一个返回给浏览器，所以需要克隆。</span></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line">            <span class="comment">// 缓存新请求</span></span><br><span class="line">            caches.open(SW_CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                cache.put(req, responseToCache);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在sw.js文件中监听install事件，即监听serviceWorker的安装，这里的self代表ServiceWorkerGlobalScope 全局作用域，e.waitUntil方法接收一个promise作为参数，这里的waitUtil会在serviceWorker脚本安装成功之前执行一些预装的操作，但是只建议做一些轻量级和非常重要资源的缓存，减少安装失败的概率。安装成功后ServiceWorker状态会从installing变为installed。SW_CACHE_NAME代表这个缓存的名字，cacheList代表初次缓存的文件。</p>
<p>上面的代码中，可以看到通过caches.open方法打开我们指定的cache文件名，然后我们调用cache.addAll并传入我们的缓存文件数组。这是通过一连串的promise（caches.open和caches.addAll）完成的event.waitUntil拿到一个promise的状态来获取安装是否成功，如果所有的文件都被缓存成功了，那么Service Worker就安装成功了。如果任何一个文件下载安装失败，那么整个Service Worker的安装就失败。这意味着你需要非常谨慎地决定那些文件需要在安装步骤中被缓存，指定太多文件的话就会增加整个Service Worker应用安装失败的概率。</p>
<p>监听fetch事件，即Service Worker可以监听网络请求，当Service Worker被安装成功并且用户浏览了另一个页面，Service Worker将开始接受fetch事件。event.respondWith里我们传入了一个由caches.match产生的promise.caches.match查找request中被Service Worker缓存命中的response。如果我们有一个命中的response，我们返回被缓存的值，否则我们返回一个实时从网络请求的结果。</p>
<h2 id="Service-Worker相关的事件"><a href="#Service-Worker相关的事件" class="headerlink" title="Service Worker相关的事件"></a>Service Worker相关的事件</h2><h3 id="1-fetch事件"><a href="#1-fetch事件" class="headerlink" title="1. fetch事件"></a>1. fetch事件</h3><p>在页面发起http/https请求时，Service Worker可以通过fetch事件拦截请求，并且给出自己的相应。w3c提供了一个新的fetch API可用于取代XMLHttpRequest，与XMLHttpRequest最大的不同就是：fetch方法返回的是promise对象，可通过then方法进行连续调用，减少嵌套。</p>
<h3 id="2-message事件"><a href="#2-message事件" class="headerlink" title="2. message事件"></a>2. message事件</h3><p>页面和ServiceWorker质检可以通过postMessage方法发送消息，发送的消息可以通过message事件接收到。这是一个双向的过程，页面可以发消息给Service Worker，Service Worker也可以发送消息给页面，由于这个特性，可以将Service Worker作为中间纽带，使得一个域名或者子域名下的多个页面自由通信页可以实现服务器消息推送的功能。</p>
<p>项目demo地址：<a href="https://github.com/Webrambler/ServiceWorker-offline-source-demo" title="ServiceWorker-offline-source-demo">ServiceWorker-offline-source-demo</a></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript学习日记《三》常用的内置工具类型</title>
    <url>/2022/06/19/typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E3%80%8A%E4%B8%89%E3%80%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p><code>Record&lt;keyType, valueType&gt;</code>Record的内部定义，接收两个泛型参数；Record后面的泛型就是对象键和值的类型。<br>定义一个对象的 key 和 value 类型该怎么做呢？这时候就需要用到 TS 的 Record 了。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Record&lt;K extends string | number | symbol, T&gt; = &#123;</span><br><span class="line">    [P in K]: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface PageInfo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;</span><br><span class="line"></span><br><span class="line">const nav: Record&lt;Page, PageInfo&gt; = &#123;</span><br><span class="line">  about: &#123; title: &quot;about&quot; &#125;,</span><br><span class="line">  contact: &#123; title: &quot;contact&quot; &#125;,</span><br><span class="line">  home: &#123; title: &quot;home&quot; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type keys = &#x27;A&#x27; | &#x27;B&#x27; | &#x27;C&#x27;</span><br><span class="line">const result: Record&lt;keys, number&gt; = &#123;</span><br><span class="line">  A: 1,</span><br><span class="line">  B: 2,</span><br><span class="line">  C: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><p><code>Partial&lt;T&gt;</code>作用：生成一个新类型，该类型与 T 拥有相同的属性，但是所有属性皆为可选项。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P in kefof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">type Bar = Partial&lt;Foo&gt;</span><br><span class="line">// 相当于</span><br><span class="line">type Bar = &#123;</span><br><span class="line">    name?: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><p><code>Required&lt;T&gt;</code>作用：生成一个新类型，该类型与 T 拥有相同的属性，但是所有属性皆为必选项。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Require&lt;T&gt; = &#123;</span><br><span class="line">    [p in keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line">type Bar = Partial&lt;Foo&gt;</span><br><span class="line">// 相当于</span><br><span class="line">type Bar = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><p><code>Readonly&lt;T&gt;</code>作用：生成一个新类型，T 中的 K 属性是只读的，K 属性是不可修改的。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Require&lt;T&gt; = &#123;</span><br><span class="line">    [p in keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todo: Readonly&lt;Todo&gt; = &#123;</span><br><span class="line">  title: &quot;Delete inactive users&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.title = &quot;Hello&quot;;</span><br><span class="line">// Cannot assign to &#x27;title&#x27; because it is a read-only property.</span><br></pre></td></tr></table></figure>
<h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><p><code>Pick&lt;T, Keys&gt;</code>作用：生成一个新类型，该类型拥有 T 中的 K 属性集 。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Pick&lt;T, K extends keyof T&gt; = &#123;</span><br><span class="line">    [P in K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  completed: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;</span><br><span class="line"></span><br><span class="line">const todo: TodoPreview = &#123;</span><br><span class="line">  title: &quot;Clean room&quot;,</span><br><span class="line">  completed: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h2><p><code>Exclude&lt;T, U&gt;</code>作用：从T类型中排除U类型生成的新类型（相当于取差集）。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Exclude&lt;T, U&gt; = T extends U ? never : T</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type A = number | string | boolean</span><br><span class="line">type B = number | boolean</span><br><span class="line"></span><br><span class="line">type Foo = Exclude&lt;A, B&gt;</span><br><span class="line">// 相当于</span><br><span class="line">type Foo = string;</span><br></pre></td></tr></table></figure>
<h2 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h2><p>和 Exclude 相反（相当于取交集）。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Extract&lt;T, U&gt; = T extends U ? T : never</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type T0 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;;</span><br><span class="line">// 相当于  type T0 = &quot;a&quot;</span><br><span class="line">type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;;</span><br><span class="line">// 相当于  type T1 = () =&gt; void</span><br></pre></td></tr></table></figure>
<h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><p><code>Omit&lt;T, keysType&gt;</code>作用：生成一个新类型，该类型拥有 T 中除了 keysType 属性以外的所有属性。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">	name: string</span><br><span class="line">	age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bar = Omit&lt;Foo, &#x27;age&#x27;&gt;</span><br><span class="line">// 相当于</span><br><span class="line">type Bar = &#123;</span><br><span class="line">	name: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h2><p><code>NonNullable&lt;T&gt;</code>作用：从泛型 T 中排除掉 null 和 undefined。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NonNullable&lt;T&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span><br><span class="line"></span><br><span class="line">type t = NonNullable&lt;&#x27;name&#x27; | undefined | null&gt;;</span><br><span class="line">/* type t = &#x27;name&#x27; */</span><br></pre></td></tr></table></figure>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p><code>Parameters&lt;T&gt;</code>从<strong>函数类型</strong>T的参数中使用的类型构造元组类型。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameters&lt;T extends (...args: any) =&gt; any&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type t = Parameters&lt;(name: string) =&gt; any&gt;; // type t = [string]</span><br><span class="line"></span><br><span class="line">type t2 = Parameters&lt;((name: string) =&gt; any)  | ((age: number) =&gt; any)&gt;; // type t2 = [string] | [number]</span><br></pre></td></tr></table></figure>
<h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h2><p><code>ConstructorParameters&lt;T&gt;</code>从<strong>构造函数类型</strong>T的参数中使用的类型构造元组类型。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConstructorParameters&lt;T extends new (...args: any) =&gt; any&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type t = ConstructorParameters&lt;(new (name: string) =&gt; any)  | (new (age: number) =&gt; any)&gt;;</span><br><span class="line">// type t = [string] | [number]</span><br></pre></td></tr></table></figure>

<h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><code>ReturnType&lt;T&gt;</code>作用：获得函数返回值的类型。<br>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type t = ReturnType&lt;(name: string) =&gt; string | number&gt;;</span><br><span class="line">// type t = string | number;</span><br><span class="line"></span><br><span class="line">type T0 = ReturnType&lt;() =&gt; string&gt;; // string</span><br><span class="line">type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // void</span><br><span class="line">type T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // &#123;&#125;</span><br><span class="line">type T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[]</span><br><span class="line">type T4 = ReturnType&lt;any&gt;; // any</span><br><span class="line">type T5 = ReturnType&lt;never&gt;; // any</span><br><span class="line">type T6 = ReturnType&lt;string&gt;; // Error</span><br><span class="line">type T7 = ReturnType&lt;Function&gt;; // Error</span><br></pre></td></tr></table></figure>

<h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h2><p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InstanceType&lt;T extends new (...args: any) =&gt; any&gt;</span><br></pre></td></tr></table></figure>

<p><code>InstanceType&lt;T&gt;</code>用于获取构造函数的返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type t = InstanceType&lt;new (name: string) =&gt; &#123;name: string, age: number&#125;&gt;</span><br><span class="line">/* 相当于</span><br><span class="line">type t = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript学习日记《一》特殊符号的含义</title>
    <url>/2022/06/18/typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E3%80%8A%E4%B8%80%E3%80%8B%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行;</p>
<p>?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数;</p>
<p>! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined;</p>
<p>!.  在变量名后添加，可以断言排除undefined和null类型;</p>
<p>_ 数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 1_101_324 = 1101324;</p>
<p>** 求幂,比如3**2 = 9;</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3脚手架配合express搭建devserver</title>
    <url>/2021/12/31/vue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E5%90%88express%E6%90%AD%E5%BB%BAdevserver/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近期本人在github上自己用最新的vue-cli3脚手架初始化了一个移动端的项目，因为项目中要访问某大厂的后端接口，而他们的接口又设置某些头部跨域验证，所以，不得不在本地起一个devserver，用作接口代理转发。</p>
<h2 id="说说旧版的vue-cli搭建devserver"><a href="#说说旧版的vue-cli搭建devserver" class="headerlink" title="说说旧版的vue-cli搭建devserver"></a>说说旧版的vue-cli搭建devserver</h2><p>在说新版的脚手架之前，先来看一看以前的vue脚手架怎么配合express来搭建devserver。</p>
<p>我们在使用第三方框架例如vue，react在进行开发时，其代码是不能直接运行在浏览器上的，原因是浏览器不认识那些语法，这时我们会使用webpack进行编译打包转换为浏览器可执行的代码。但是试想我们在进行开发时，没写一行代码就要进行编译打包，然后再在浏览器里运行查看效果，这无疑大大降低了我们的开发效率，所以我们能不能让工具自己检测到代码变化然后自己自动的编译打包，然后我们便可以实时的查看到页面效果了。</p>
<p>首先，我们需要了解构建自己的devserver所需要用到的最基本的几个插件：<a href="https://www.npmjs.com/package/webpack-dev-middleware" title="webpack-dev-middleware">webpack-dev-middleware</a>，<a href="https://www.npmjs.com/package/webpack-dev-middleware" title="webpack-hot-middleware">webpack-hot-middleware</a>，<a href="https://www.npmjs.com/package/webpack-dev-middleware" title="http-proxy-middleware">http-proxy-middleware</a>。</p>
<h2 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h2><p>webpack-dev-middleware插件，该插件对文件进行监听，当检测到代码变化时会主动对代码进行重新的编译，正如官网所介绍的，使用此插件的几个好处：</p>
<p>1.No files are written to disk, rather it handles files in memory.（编译后的文件会存在于内存中，而不是在磁盘中）</p>
<p>2.If files changed in watch mode, the middleware delays requests until compiling has completed.（如果文件的变化处于watch模式下，该中间件会在编译完成之后再进行资源的请求）</p>
<p>3.Supports hot module reload (HMR).（支持模块热加载技术）</p>
<p>具体使用，我就不多介绍了，请去看官网 <a href="https://www.npmjs.com/package/webpack-dev-middleware" title="webpack-dev-middleware的用法(传送门)">webpack-dev-middleware的用法(传送门)</a></p>
<h2 id="webpack-hot-middleware"><a href="#webpack-hot-middleware" class="headerlink" title="webpack-hot-middleware"></a>webpack-hot-middleware</h2><p>webpack-hot-middleware是用来进行页面的热重载的，刷新浏览器 一般和 webpack-dev-middleware 配合使用，实现热加载功能。它的核心功能就是实现浏览器端的热重载，和webpack-dev-server达到类似的功能。关于它的使用，总结为以下几点：</p>
<p>1.在webpack的配置文件的plugins中增加HotModuleReplacementPlugin()；</p>
<p>2.在webpack的配置文件entry中新增webpack-hot-middleware/client入口，比如下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: [<span class="string">&#x27;webpack-hot-middleware/client?reload=true&#x27;</span>, path.resolve(__dirname, <span class="string">&#x27;./src/main.js&#x27;</span>))]</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在server文件中，express中加入中间件webpack-hot-middleware，如下这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;webpack-hot-middleware&#x27;</span>)(compiler));</span><br></pre></td></tr></table></figure>
<p>4.在入口文件处添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">	<span class="built_in">module</span>.hot.accept()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该插件的详细使用请查看官网：<a href="https://www.npmjs.com/package/webpack-hot-middleware" title="webpack-hot-middleware详细介绍（传送门）">webpack-hot-middleware详细介绍（传送门）</a></p>
<h2 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h2><p>http-proxy-middleware用于将请求转发给其它服务器，常用于本地开发服务器的接口代理。</p>
<p>这个插件使用比较简单，这里不再赘述了，详细使用请查看官网：<a href="https://www.npmjs.com/package/webpack-hot-middleware" title="传送门">传送门</a></p>
<h2 id="旧版的vue-cli结合express所构建的devserver"><a href="#旧版的vue-cli结合express所构建的devserver" class="headerlink" title="旧版的vue-cli结合express所构建的devserver"></a>旧版的vue-cli结合express所构建的devserver</h2><p>通过我们上面的分析，我们大致有了构建devserver的方向，话不多说，直接上code：</p>
<p>先来看node入口文件server.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> proxyMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyTable = config.dev.proxyTable</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> devMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>)(compiler, &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath,</span><br><span class="line">  <span class="attr">quiet</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hotMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-hot-middleware&#x27;</span>)(compiler, &#123;</span><br><span class="line">  <span class="attr">log</span>: <span class="function"><span class="params">info</span> =&gt;</span> <span class="built_in">console</span>.log(info)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(proxyTable).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = proxyTable[context]</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    options = &#123; <span class="attr">target</span>: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.use(proxyMiddleware(options.filter || context, options))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle fallback for HTML5 history API</span></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>)())</span><br><span class="line"></span><br><span class="line">app.use(devMiddleware)</span><br><span class="line"></span><br><span class="line">app.use(hotMiddleware)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>然后webpack的配置文件入口处添加 ‘webpack-hot-middleware/client?reload=true’ ，plugins中添加new webpack.HotModuleReplacementPlugin()。还有项目主入口文件记得添加接受模块热更新的逻辑代码即可。</p>
<p>以上就是旧版的vue-cli脚手架结合express及其中间件所构建的devserver。</p>
<p>下面，我们来看最新的vue-cli3（即@vue/cli）怎么构建devserver呢？</p>
<h2 id="新版的-vue-cli构建devserver"><a href="#新版的-vue-cli构建devserver" class="headerlink" title="新版的@vue/cli构建devserver"></a>新版的@vue/cli构建devserver</h2><p>众所周知，使用最新版的vue脚手架@vue/cli的时候，其配置文件不再是webpack.config.js，而变成了vue.config.js文件，我们阅读过它的文档都知道，它的配置和原始的webpack配置并不相同，而是内部做了一些封装。关于vue.config.js的详细配置请查看@vue/cli配置文件文档</p>
<p><strong>下面最关键的部分来了</strong>：我会写出我思考的全部过程，会写的很细，如何从零到有。</p>
<p>我刚开始分析使用最新版vue脚手架进行构建devserver的时候，想到只要能够通过vue.config.js经过转换之后得到最原始的webpack.config.js的配置内容即可，那接下来就可以使用旧版的那一套。思路确定了之后，首先明确，既然脚手架的作者让我们遵循它所制定的一套规则（即<a href="https://cli.vuejs.org/zh/config/" title="@vue/cli官方文档">@vue/cli官方文档</a>）配置vue.config.js，那么其内部肯定是写了如何把这个vue.config.js解析为最原始的webpack.config.js的配置文件。</p>
<p>明确了第一个目标后，我先去看了项目的package.json：<br><a href="https://img-blog.csdnimg.cn/20191101023006564.png"><img src="https://img-blog.csdnimg.cn/20191101023006564.png"></a></p>
<p>众所周知，这个serve命令是我们在启动本地开发环境时的命令。由这个指令我去看了node_modules里面的@vue包下面的cli-service包：<br><a href="https://img-blog.csdnimg.cn/20191101023232540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191101023232540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>然后，先看此包的package.json文件（即node_modules/@vue/cli-service/package.json）：<br><a href="https://img-blog.csdnimg.cn/20191101023458588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191101023458588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>可以看到main和bin的配置，然后知道此包对外暴漏的入口文件为lib/Service.js文件，而根项目目录所执行的serve命令中的vue-cli-service其实就是此包（即node_modules/@vue/cli-service）下的bin文件夹下的vue-cli-service.js文件，我们打开bin文件夹和lib文件夹，果不其然：<br><a href="https://img-blog.csdnimg.cn/20191101024341125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191101024341125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>然后，我先去仔细阅读了执行vue-cli-service命令的文件，即bin/vue-cli-service.js文件，代码量并不大：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> semver = <span class="built_in">require</span>(<span class="string">&#x27;semver&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; error &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-shared-utils&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> requiredVersion = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>).engines.node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!semver.satisfies(process.version, requiredVersion)) &#123;</span><br><span class="line">  error(</span><br><span class="line">    <span class="string">`You are using Node <span class="subst">$&#123;process.version&#125;</span>, but vue-cli-service `</span> +</span><br><span class="line">    <span class="string">`requires Node <span class="subst">$&#123;requiredVersion&#125;</span>.\nPlease upgrade your Node version.`</span></span><br><span class="line">  )</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;../lib/Service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="keyword">new</span> Service(process.env.VUE_CLI_CONTEXT || process.cwd())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rawArgv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">require</span>(<span class="string">&#x27;minimist&#x27;</span>)(rawArgv, &#123;</span><br><span class="line">  <span class="attr">boolean</span>: [</span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="string">&#x27;modern&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;report&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;report-json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;watch&#x27;</span>,</span><br><span class="line">    <span class="comment">// serve</span></span><br><span class="line">    <span class="string">&#x27;open&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="comment">// inspect</span></span><br><span class="line">    <span class="string">&#x27;verbose&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> command = args._[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">service.run(command, args, rawArgv).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  error(err)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到 new Service创建了一个Service的实例，变量command为我们所执行的命令的环境标志（即若我们执行的是“vue-cli-service serve”命令，那command即为serve），最后执行了实例的run方法，很明显run的是command命令。</p>
<p>然后再去看看lib/Service.js主入口文件（代码量有点大，就不在此复制粘贴了），我们挑重要的看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">resolvePkg</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">loadEnv</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolvePlugins</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;...&#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolveChainableWebpackConfig</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolveWebpackConfig</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">loadUserOptions</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过一番分析之后得知，每个方法的用意，比如 init 方法，它就是初始化配置的，把一些vue.config.js里面的一些配置加入到实例属性上（比如chainWebpack，configureWebpack），以便于以后的解析。resolveChainableWebpackConfig方法就是解析vue.config.js中的chainWebpack配置，将其转化为原始的webpack配置。resolveWebpackConfig方法就是将配置转化为原始的webpack配置的方法，只要调用Service实例的resolveWebpackConfig，即可将vue.config.js配置转换为webpack.config.js（笔者还去读了里边很多的文件，过程太复杂就不再这里一一赘述了）。</p>
<p>然后发现此包中的webpack.config.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this file is for cases where we need to access the</span></span><br><span class="line"><span class="comment">// webpack config as a file when using CLI commands.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> service = process.VUE_CLI_SERVICE</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!service || process.env.VUE_CLI_API_MODE) &#123;</span><br><span class="line">  <span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;./lib/Service&#x27;</span>)</span><br><span class="line">  service = <span class="keyword">new</span> Service(process.env.VUE_CLI_CONTEXT || process.cwd())</span><br><span class="line">  service.init(process.env.VUE_CLI_MODE || process.env.NODE_ENV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = service.resolveWebpackConfig()</span><br></pre></td></tr></table></figure>
<p>看到最后的module.exports = service.resolveWebpackConfig()，我就知道我找到我所想要的东西了，原来此文件就是将vue.config.js转换为最原始的webpack的配置文件，再加上此js文件最开头的那两行注释：this file is for cases where we need to access the webpack config as a file when using CLI commands.（此文件用于在使用CLI命令时需要将webpack配置文件作为文件访问的情况。）这两行注释更加明确了我的寻找是正确的。（其实，笔者一开始没注意到这个文件，直到看到lib/commands/serve.js文件时才去看了webpack.config.js，才发现原来众里寻他千百度，那文件却在手边眼前处……）</p>
<h2 id="新版脚手架的devserver配置（重要）"><a href="#新版脚手架的devserver配置（重要）" class="headerlink" title="新版脚手架的devserver配置（重要）"></a>新版脚手架的devserver配置（重要）</h2><p>由此，我们已经找到了我们想要的把vue.config.js转换为最原始的webpack配置文件，所以，我们想要构建devserver变得异常容易，只需要将webpack的配置文件引入的地方改成下面的引入方式即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service/webpack.config.js&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>由此，我们就已经完成了我们的目标：利用@vue/cli脚手架搭配express搭建devserver。</p>
<p>纯属个人理解，如有异议，欢迎大家留言来一起探讨。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2.5+typescript的采坑系列《一》</title>
    <url>/2021/12/13/vue2-5-typescript%E7%9A%84%E9%87%87%E5%9D%91%E7%B3%BB%E5%88%97%E3%80%8A%E4%B8%80%E3%80%8B/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近笔者在使用vue2.5+typescript构建项目，其实是自己写着玩的，本着探索+分享的目的，在GitHub新建了一个项目，技术选型vue2.5+typescript，因为之前一直没有使用vue+typescript构建项目，所以就想尝试一下，没想到vue+ts却是巨坑多多啊。。。下面开始带大家一起看看，那些年我们一起踩过的坑</p>
<h2 id="1-引入-vue文件不能省略文件扩展名"><a href="#1-引入-vue文件不能省略文件扩展名" class="headerlink" title="1.引入.vue文件不能省略文件扩展名"></a>1.引入.vue文件不能省略文件扩展名</h2><p>看到上述小标题，你或许会感叹：纳尼？写惯了省略文件后缀名，但是在vue+typescript的项目中，是不能省略.vue文件的扩展名的，起初，笔者引入vue组件，一直报错，而且笔者在webpack的配置中已经配置了extensions中加入了’.vue’，but木有用啊，说起来都是泪，我也是写惯了配置了extensions之后省略文件后缀名的写法，愣是检查了二十多分钟，实在是看不出来哪里错了，最后不得不去某技术网站搜索，终于十分钟之后，终于明白了，原因居然是不能省略文件扩展名，笔者表示无语。这是笔者使用vue2.5+typescript 踩过的第一个坑，特此告知，以免后来者犯同样的错误。。。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue作用域插槽slot-scope详解</title>
    <url>/2021/12/12/vue%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BDslot-scope%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>vue的插槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。</strong> 实际上，一个slot最核心的两个问题这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。</p>
<p>了解vue的同学都知道插槽分为单个插槽，具名插槽，还有作用域插槽，前两种比较简单这里就不赘述了，今天的重点是讨论作用域插槽。</p>
<p>简单来说，前两种插槽的内容和样式皆由父组件决定，也就是说显示什么内容和怎样显示都由父组件决定；但是第三种插槽就不同了，作用域插槽的样式由父组件决定，内容却由子组件控制。简单来说：前两种插槽不能绑定数据，作用域插槽是一个带绑定数据的插槽。</p>
<p>由于Vue官方在2.6版本以后改变了插槽的书写方式，所以，我们这里区分2.6版本之前的写法和2.6版本以后的写法：</p>
<h2 id="vue2-6之前的版本作用域插槽的写法"><a href="#vue2-6之前的版本作用域插槽的写法" class="headerlink" title="vue2.6之前的版本作用域插槽的写法"></a>vue2.6之前的版本作用域插槽的写法</h2><p>我们先来看2.6版本之前的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;a.item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    child</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:item</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  data () &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">items</span>:[<span class="string">&#x27;Webkit&#x27;</span>,<span class="string">&#x27;Gecko&#x27;</span>,<span class="string">&#x27;Trident&#x27;</span>,<span class="string">&#x27;Blink&#x27;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="vue2-6-x的版本作用域插槽的写法"><a href="#vue2-6-x的版本作用域插槽的写法" class="headerlink" title="vue2.6.x的版本作用域插槽的写法"></a>vue2.6.x的版本作用域插槽的写法</h2><p>再来看2.6版本之后的写法，子组件的写法不用变，和原来一模一样，来看父组件的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;a.item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    child</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以清晰的看到，在子组件中有个插槽slot通过v-bind绑定了一个值item，在父组件中引用了子组件child，child标签里面可以看到作用域插槽template，此时slot-scope就是一个对象，这个对象是由子组件的插槽slot所绑定的值所组成的一个对象，比如在这里slot-scope = {item}，这里的item来自子组件，而这里slot-scope的值是a，所以就有了下面的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-text=<span class="string">&quot;a.item&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>说到这里，想必大家都应该明白了作用域插槽了吧，简单来说就一句话：可以绑定数据的插槽，显示内容完全由子组件决定，数据来自子组件。</p>
<p>如果绑定数据太多，而你不需要全都用到的时候可以使用es6的对象解构，关于对象解构比较简单，笔者在此就不再赘述了！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue在父组件中改变子组件中的某个样式</title>
    <url>/2021/12/13/vue%E5%9C%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%94%B9%E5%8F%98%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="vue组件样式穿透"><a href="#vue组件样式穿透" class="headerlink" title="vue组件样式穿透"></a>vue组件样式穿透</h2><p>在应用vue开发前端项目时，有时候我们需要在父组件中改变子组件的默认样式，比如你的项目中引用了第三方UI库，但是你觉得某个组件的样式你并不喜欢，那么你想改变它的默认样式，那么我们该怎么办呢？</p>
<p>直接上代码，先来看父组件Home.vue的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件Home.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is Home Component!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">HelloWorld</span>/&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// @ is an alias to /src</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;@/components/HelloWorld.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    HelloWorld</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-tag">h1</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">color</span>: brown;</span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>再来看子组件HelloWorld.vue的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件HelloWorld.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>This is HelloWorld Component!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;HelloWorld&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- Add <span class="string">&quot;scoped&quot;</span> attribute to limit CSS to <span class="built_in">this</span> component only --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-class">.title</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">color</span>: <span class="number">#42b983</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>那么，我们先来看一下页面的效果：<br><a href="https://img-blog.csdnimg.cn/2018123019152559.png"><img src="https://img-blog.csdnimg.cn/2018123019152559.png"></a></p>
<p>那么，接下来，我们如果想要在Home.vue中写样式想要改变其子组件HelloWorld.vue中”This is HelloWorld!”这句话的某个样式，比如说字体颜色，那么，我们该怎么办呢？</p>
<p>如果，我们直接在Home.vue的style标签中直接这样写可以吗？如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue组建</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is Home Component!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">HelloWorld</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// @ is an alias to /src</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;@/components/HelloWorld.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    HelloWorld</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-tag">h1</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: brown;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.home</span> <span class="selector-class">.title</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: rebeccapurple;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>直接在Home.vue中想要控制子组件的样式，直接这样写，明显是不会生效的！</p>
<h2 id="vue2-x的组件样式穿透写法"><a href="#vue2-x的组件样式穿透写法" class="headerlink" title="vue2.x的组件样式穿透写法"></a>vue2.x的组件样式穿透写法</h2><p>那么，我们该怎么办呢？此时，我们可以使用深度作用选择器，如果你希望组件 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p>
<p>比如就上述例子而言，你可以Home.vue中scoped的样式改为下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1 &#123;</span><br><span class="line">  <span class="attr">color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line">.home &gt;&gt;&gt; .title &#123;</span><br><span class="line">  <span class="attr">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>如此，将会达到我们想要的效果拉了！看下页面效果：<br><a href="https://img-blog.csdnimg.cn/20181230192833676.png"><img src="https://img-blog.csdnimg.cn/20181230192833676.png"></a></p>
<p>可以看到，子组件的字体颜色已经改变了！</p>
<p>如果是有些像 Sass、less 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 操作符取而代之——这是一个 &gt;&gt;&gt; 的别名，同样可以正常工作。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line">h1 &#123;</span><br><span class="line">  <span class="attr">color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line">.home &#123;</span><br><span class="line">  <span class="regexp">/deep/</span> .title &#123;</span><br><span class="line">    <span class="attr">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue3-x的组件样式穿透写法"><a href="#vue3-x的组件样式穿透写法" class="headerlink" title="vue3.x的组件样式穿透写法"></a>vue3.x的组件样式穿透写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line">h1 &#123;</span><br><span class="line">  <span class="attr">color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line">.home &#123;</span><br><span class="line">  :<span class="function"><span class="title">deep</span>(<span class="params">.title</span>)</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：vue3.x已经删除了 /deep/ 和 &gt;&gt;&gt; 操作符，请务必使用:deep()进行组件样式穿透。</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽slot踩坑--父组件通信</title>
    <url>/2021/12/19/vue%E6%8F%92%E6%A7%BDslot%E8%B8%A9%E5%9D%91-%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>当我们在封装vue组件时，难免会用到插槽slot来进行子组件的嵌套，那么，当slot插槽处的内容组件需要和父组件进行通信时，怎么办呢？场景代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            </span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">onInput</span>(<span class="params"></span>)</span>&#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用的时候，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>首先，我们都知道，在vue中，子组件向父组件进行通信传值时，是借用在子组件中派发自定义事件，然后在父组件中的子组件引用之处进行监听自定义事件，如下(@test=”demo”)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">child</span> @<span class="attr">test</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;child.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">components</span>:&#123;child&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">demo</span>(<span class="params">val</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(val)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">onInput</span>(<span class="params">e</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;test&#x27;</span>, e.target.value)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>但是，插槽slot是无法进行自定义事件的监听的，换言之，此种写法会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;slot @test=<span class="string">&quot;fn&quot;</span>&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure>
<p>那么，怎么解决这种问题呢？其实方法有很多，笔者这里说下自己的解决方案：</p>
<p>我们可以在子组件中调用父组件去触发一个自定义事件，然后在父组件自己的生命周期函数中对这个自定义事件进行监听，code如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.$on(<span class="string">&#x27;test&#x27;</span>, <span class="built_in">this</span>.fn)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">fn</span>(<span class="params">val</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(val)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// child.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">onInput</span>(<span class="params">e</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$parent.$emit(<span class="string">&quot;test&quot;</span>, e.target.value)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在这里说白了，就是要找到包含slot的组件的Vue实例的引用，然后让这个组件的实例自己去触发那个约定好的自定义事件，然后由于它自己在自己的Vue实例初始化的时候已经对这个自定义事件进行了监听$on，所以当它自己的实例以$emit的形式触发该自定义事件的时候，所监听的事件就会触发相应的回调，从而达到通信的目的。</p>
<p>要找到此实例也很容易，像上述利用$parent($children)的形式只是其中的一种，我们再来看一下另外一种形式($refs)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.vue （包含slot的组件）</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.$on(<span class="string">&#x27;test&#x27;</span>, <span class="built_in">this</span>.fn)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">fn</span>(<span class="params">val</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(val)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用组件parent的地方</span></span><br><span class="line"><span class="comment">// Test.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">ref</span>=<span class="string">&#x27;parent&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;clickFn&#x27;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">&#x27;./parent.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">components</span>: &#123;parent&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">clickFn</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$refs.parent.$emit(<span class="string">&#x27;test&#x27;</span>, <span class="number">666</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>还有一种方式是利用在Vue的原型上挂载一个Vue实例，即eventBus，利用Vue实例的eventBus进行跨组件间的通信；再更进一步也可以利用vuex，但是个人觉得无此必要。</p>
<p>这样即可解决slot插槽与其父组件的通信问题了！</p>
<p>另符vue官方文档对于监听自定义事件的说明：<a href="https://cn.vuejs.org/v2/api/#vm-on" title="vue中$on的说明">vue中$on的说明</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue无痕刷新组件</title>
    <url>/2021/12/14/vue%E6%97%A0%E7%97%95%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>在vue项目中，很多场景需要我们刷新组件，一般常用的两种刷新方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.reload()，原生 js 提供的方法；</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.go(<span class="number">0</span>)，vue 路由里面的一种方法；</span><br></pre></td></tr></table></figure>

<p>这两种方法都可以达到页面刷新的目的，简单粗暴，但是用户体验不好，相当于按 F5 刷新页面，页面的重新载入，会有短暂的白屏。</p>
<p>那么，怎么实现无痕刷新呢？</p>
<p>原理：<br>先在全局组件注册一个方法，用该方法控制router-view的显示与否，然后在子组件调用。</p>
<p>步骤：</p>
<ol>
<li>v-if控制<router-view></router-view>的显示。</li>
<li>provide：全局注册方法。</li>
<li>methods：设置reload方法。</li>
<li>在子组件中使用inject插入父组件的刷新方法。</li>
</ol>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>在app.vue里面设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;refresh&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span>  <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">reload</span>:<span class="built_in">this</span>.reload</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">refresh</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">reload</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.refresh = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.refresh = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在.vue子组件中使用，先用inject注册，然后即可通过this调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">inject</span>:[<span class="string">&#x27;reload&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如此，就可以随时刷新当前组件了！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue如何禁止弹窗后面的滚动条滚动？</title>
    <url>/2022/01/01/vue%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E5%BC%B9%E7%AA%97%E5%90%8E%E9%9D%A2%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>话不多说，直接上code：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods : &#123;</span><br><span class="line">    <span class="comment">//禁止滚动</span></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mo=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;e.preventDefault();&#125;;</span><br><span class="line">        <span class="built_in">document</span>.body.style.overflow=<span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchmove&quot;</span>,mo,<span class="literal">false</span>);<span class="comment">//禁止页面滑动</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/***取消滑动限制***/</span></span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mo=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;e.preventDefault();&#125;;</span><br><span class="line">        <span class="built_in">document</span>.body.style.overflow=<span class="string">&#x27;&#x27;</span>;<span class="comment">//出现滚动条</span></span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;touchmove&quot;</span>,mo,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue脚手架有话说</title>
    <url>/2021/12/13/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%9C%89%E8%AF%9D%E8%AF%B4/</url>
    <content><![CDATA[<h2 id="1-vue3-0脚手架与vue2-x脚手架并存"><a href="#1-vue3-0脚手架与vue2-x脚手架并存" class="headerlink" title="1.vue3.0脚手架与vue2.x脚手架并存"></a>1.vue3.0脚手架与vue2.x脚手架并存</h2><p>安装最新的vue3.0的脚手架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>如果你想同时保留vue2.x的脚手架，你可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># vue init 的运行效果将会跟 vue-cli@2.x 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<h2 id="2-vue-cli-2-x版本"><a href="#2-vue-cli-2-x版本" class="headerlink" title="2.vue-cli 2.x版本"></a>2.vue-cli 2.x版本</h2><p>若是vue2.x脚手架，可以使用vue list来查看可用模板</p>
<p>第一种：</p>
<p><code>vue init webpack project-name</code></p>
<p>第二种：</p>
<p><code>vue init webpack-simple project-name</code></p>
<p>相对来说，第二种的目录比第一种要简单的多，对于配置项可以自己定制化的去配置；第一种比第二种目录要复杂得多，但是基本配置都比较全；</p>
<p>3.vue-cli 3.0版本</p>
<p><code>vue create project-name</code></p>
<p>3.0的脚手架生成的项目，相比前面2.x的版本，又要精简优雅的多，而且没有了<code>webpack.config.js</code>配置文件，新的配置文件叫做<code>vue.config.js</code>，babel的配置文件也变了，变为了<code>babel.config.js</code>；</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue踩坑之eventBus.多次触发的问题</title>
    <url>/2022/01/01/vue%E8%B8%A9%E5%9D%91%E4%B9%8BeventBus-%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>记录一下自己使用vue踩过的坑，希望别人看到能避免如此踩坑。<br>先描述问题：<br>假设有两个非父子组件A和组件B，组件A的data中绑定的某个值变化时，通知组件B需要做某些操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件A</span></span><br><span class="line"><span class="built_in">this</span>.value = <span class="number">1</span></span><br><span class="line">eventBus.$emit(<span class="string">&#x27;getSomething&#x27;</span>, <span class="built_in">this</span>.value)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件B</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	eventBus.$on(<span class="string">&#x27;getSomething&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现，当组件A已经触发了事件getSomething的时候，第一次切换到组件B时，控制台会打印一次value的值，也就是1；但是当第二次切换到组件B时，会打印两次1，第三次会打印三次，如此累加，这样就会导致很多问题。</p>
<p>解决方法：<br>法一：在每次$on之前调用$off卸载掉事件，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件B</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	eventBus.$off(<span class="string">&#x27;getSomething&#x27;</span>)</span><br><span class="line">	eventBus.$on(<span class="string">&#x27;getSomething&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二：在生命周期beforeDestroy里面调用$off卸载掉事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件B</span></span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	eventBus.$off(<span class="string">&#x27;getSomething&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你有更好的解决方法，欢迎留言探讨。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack使用proxy代理时pathRewrite不生效的分析</title>
    <url>/2021/12/12/webpack%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E7%90%86%E6%97%B6pathRewrite%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近日来，连续高压的做项目，都没时间来写点东西，今天浏览帖子时发现好多同学在问proxy使用pathRewrite重写路径时不生效的问题，一时兴起就想写篇文章告诉还不清楚的同学们。</p>
<hr>
<h2 id="概述前端打包工具"><a href="#概述前端打包工具" class="headerlink" title="概述前端打包工具"></a>概述前端打包工具</h2><p>由于近些年来react、vue等MVVM框架的流行，使得前端的打包工具更倾向于webpack，相比传统的打包工具gulp，grunt等，webpack对于使用vue、react等构建的单页面应用有着超强的亲和力，再加上前端模块化的大趋势，webpack对于处理模块化有着天生的神力，由此webpack自然从众多的打包工具中脱颖而出。</p>
<hr>
<h2 id="直入主题pathRewrite"><a href="#直入主题pathRewrite" class="headerlink" title="直入主题pathRewrite"></a>直入主题pathRewrite</h2><p>简单来说，pathRewrite是使用proxy进行代理时，对请求路径进行重定向以匹配到正确的请求地址，话不多说，上代码，我们先来看看不使用pathRewrite的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">&#x27;/csdn&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们现在想请求CSDN中某一个页面的某个接口，配置代理如上，请求代码附上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;/csdn/u014427391/article/getSideArticles?                    </span></span><br><span class="line"><span class="string">         pageindex=3&amp;articleId=84980219&amp;length=20&quot;</span>)</span><br><span class="line">         .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(response);</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>

<p>如上所示，我们简单的使用axios进行请求。实际上，我们要请求的接口地址是：<code>https://blog.csdn.net/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20</code>，配置代理<code>/csdn</code>对应的target为:<code>https://blog.csdn.net</code>，那么当我们不使用pathRewrite进行路径重定向的时候，加入我们像上述axios的代码那样进行请求时，我们代码中的GET请求是”/csdn/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20”，此时由于proxy的配置，此请求会被代理成<code>https://blog.csdn.net/csdn/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20</code>，显然可以看出，我们的请求地址中多了个<code>/csdn</code>，此时浏览器会报404错误，此时我们就需要用到pathRewrite重定向功能。</p>
<p>其实，不难看出，当我们配置了代理后，我们请求的地址前面会自动的加上我们所代理的地址，就上述我们的配置举个例子来说，就是，当我们代码中请求的地址是<code>/csdn/abc</code>的时候，我们真实请求的地址是<code>https://blog.csdn.net/csdn/abc</code>(前面会自动的加上我们所代理的地址)。</p>
<p>回归到最初的例子，当我们请求<code>/csdn/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20</code>时，我们实际上请求的是<code>https://blog.csdn.net/csdn/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20</code>，而真实的正确地址是<code>https://blog.csdn.net/u014427391/article/getSideArticles?pageindex=3&amp;articleId=84980219&amp;length=20</code>，由此发现多了个”/csdn”，由此导致浏览器报404的错误，所以由此分析，我们需要去掉请求路径中多余的”/csdn”，此时我们就需要用到pathRewrite进行路径的重定向了。直接上代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/csdn&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/csdn&#x27;</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们加了路径的重定向代码pathRewrite，上述代码以正则匹配规则将以”/csdn”开头的请求地址修改为””，也就是说，我们这样配置后，当我们请求”/csdn/abc”的时候，会被重写为请求”/abc”，直接在请求地址中将”/csdn”变成了””，由此刚好去掉了请求地址中多余的”/csdn”，由此，上述的404错误就得到了解决。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack系列之webpack性能优化</title>
    <url>/2021/12/19/webpack%E7%B3%BB%E5%88%97%E4%B9%8Bwebpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在此文中，我不会浪费篇幅给大家讲如何写配置文件。如果你想学习这方面的内容，那么完全可以去官网学习。在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点：</p>
<p>有哪些方式可以减少 Webpack 的打包时间；</p>
<p>有哪些方式可以让 Webpack 打出来的包更小；</p>
<h2 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h2><h3 id="优化loader"><a href="#优化loader" class="headerlink" title="优化loader"></a>优化loader</h3><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p>
<p>首先我们可以优化 Loader 的文件搜索范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="comment">// js 文件才使用 babel</span></span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">      <span class="attr">include</span>: [resolve(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">      <span class="comment">// 不会去查找的路径</span></span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</p>
<p>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">loader: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p>
<p>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123;</span><br><span class="line">  <span class="attr">size</span>: os.cpus().length</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">//把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行</span></span><br><span class="line">        loader: <span class="string">&#x27;happypack/loader?id=happyBabel&#x27;</span>,</span><br><span class="line">        <span class="comment">//排除node_modules 目录下的文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        include: path.resolve(__dirname, src)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">//用id来标识 happypack处理那里类文件</span></span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;happyBabel&#x27;</span>,</span><br><span class="line">      <span class="comment">//如何处理  用法和loader 的配置一样</span></span><br><span class="line">      <span class="attr">loaders</span>: [&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span>,</span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="comment">//共享进程池</span></span><br><span class="line">      <span class="attr">threadPool</span>: happyThreadPool,</span><br><span class="line">      <span class="comment">//允许 HappyPack 输出日志</span></span><br><span class="line">      <span class="attr">verbose</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>DllPlugin和DllReferencePlugin提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。</p>
<p>DllPlugin 可以将特定的类库（一般为项目中使用的第三方包）提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p>
<p>接下来我们就来学习如何使用 DllPlugin：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 想统一打包的类库</span></span><br><span class="line">    <span class="attr">vendor</span>: [<span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]-[hash]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// name 必须和 output.library 一致</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]-[hash]&#x27;</span>,</span><br><span class="line">      <span class="comment">// 该属性需要与 DllReferencePlugin 中一致</span></span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name]-manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="comment">// manifest 就是之前打包出来的 json 文件</span></span><br><span class="line">      <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./dist/vendor-manifest.json&#x27;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p>
<p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>我们还可以通过一些小的优化点来加快打包速度：</p>
<p>resolve.extensions：用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面；</p>
<p>resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径；</p>
<p>module.noParse：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助；</p>
<h2 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h2><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p>
<p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</p>
<h3 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h3><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p>
<p>比如我们希望打包两个文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们打包出来的代码会类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">concatenateModules</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p>webpack3的话，开启treeshaking，使用webpack.optimize.UglifyJsPlugin插件即可完成js文件的treeshaking；</p>
<p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack系列《一》核心概念（入门篇）</title>
    <url>/2021/12/18/webpack%E7%B3%BB%E5%88%97%E3%80%8A%E4%B8%80%E3%80%8B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1. 什么是webpack"></a>1. 什么是webpack</h2><p>作为前端开发者，<strong>webpack</strong>可谓是家喻户晓的构建工具！那么，我们先来看看英文官方对于webpack的定义和说明：</p>
<p>webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it internally builds a dependency graph which maps every module your project needs and generates one or more bundles.</p>
<p><strong>webpack</strong> 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p><strong>webPack</strong> 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>
<p><strong>webpack</strong> 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
<h2 id="2-webpack配置的核心概念"><a href="#2-webpack配置的核心概念" class="headerlink" title="2. webpack配置的核心概念"></a>2. webpack配置的核心概念</h2><h3 id="2-1-entry（打包入口）"><a href="#2-1-entry（打包入口）" class="headerlink" title="2.1 entry（打包入口）"></a>2.1 entry（打包入口）</h3><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。就vue项目来说，通常入口文件为main.js文件。<br><a href="https://img-blog.csdnimg.cn/20190325145103811.png"><img src="https://img-blog.csdnimg.cn/20190325145103811.png"></a></p>
<p>entry 通常有三种写法：</p>
<h4 id="第一种：字符串形式，如下："><a href="#第一种：字符串形式，如下：" class="headerlink" title="第一种：字符串形式，如下："></a>第一种：字符串形式，如下：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/layout/main.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种：数组形式，如下："><a href="#第二种：数组形式，如下：" class="headerlink" title="第二种：数组形式，如下："></a>第二种：数组形式，如下：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&#x27;./src/layout/main.js&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种：对象形式，如下："><a href="#第三种：对象形式，如下：" class="headerlink" title="第三种：对象形式，如下："></a>第三种：对象形式，如下：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/layout/main.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这三种写法，通常开发者都会采用第三种，实际上，我们也推荐第三种写法，不论是可扩展性还是代码可读性，第三种都秒杀前两种！</p>
<h3 id="2-2-output（打包出口）"><a href="#2-2-output（打包出口）" class="headerlink" title="2.2 output（打包出口）"></a>2.2 output（打包出口）</h3><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/layout/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.[hash:8].js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。</p>
<p>关于output还有很多可配置的属性，详情参见webpack官方文档output配置，在此不再赘述了。</p>
<h3 id="2-3-loaders（处理非js文件）"><a href="#2-3-loaders（处理非js文件）" class="headerlink" title="2.3 loaders（处理非js文件）"></a>2.3 loaders（处理非js文件）</h3><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/layout/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.[hash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上，可以看到module种配置rules规则，使用babel-loader来处理js文件，使用url-loader来处理图片文件。</p>
<p>常用的loader：</p>
<ol>
<li><p>编译相关：babel-loader，ts-loader；</p>
</li>
<li><p>样式相关：style-loader，css-loader，less-loader，sass-loader，postcss-loader；</p>
</li>
<li><p>文件相关：file-loader，url-loader；</p>
</li>
</ol>
<h3 id="2-4-plugins（插件）"><a href="#2-4-plugins（插件）" class="headerlink" title="2.4 plugins（插件）"></a>2.4 plugins（插件）</h3><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/layout/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.[hash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">NODE_ENV</span>: <span class="string">&#x27;&quot;production&quot;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">compress</span>: &#123;</span><br><span class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      <span class="attr">minimize</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack 提供许多开箱可用的插件！具体可以查阅<a href="https://webpack.js.org/plugins/" title="webpack官方文档">webpack官方文档</a>。</p>
<h3 id="2-5-mode（模式）"><a href="#2-5-mode（模式）" class="headerlink" title="2.5 mode（模式）"></a>2.5 mode（模式）</h3><p>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>  <span class="comment">// &quot;production&quot; | &quot;development&quot; | &quot;none&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webstorm快捷键（Mac版）</title>
    <url>/2021/12/12/webstorm%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88Mac%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>⌘——Command</p>
<p>⌃ ——Control</p>
<p>⌥——alt</p>
<p>⇧——Shift</p>
<p>⇪——Caps Lock</p>
<p>fn——功能键就是fn</p>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>Command+alt+T 用 (if..else, try..catch, for, etc.)包住<br>Command+/ 注释/取消注释的行注释<br>Command+alt+/ 注释/取消注释与块注释<br>alt+↑ 向上选取代码块<br>alt+↓ 向下选取代码块<br>Command+alt+L 格式化代码<br>Command++ 展开光标所在的代码块<br>Command+- 折叠光标所在的代码块<br>Command+shift++ 展开当前文件所有的折叠<br>Command+shift+- 折叠当前文件所有的代码<br>tab,shift+tab 调整缩进<br>Control+alt+I 快速调整缩进<br>Command+C 复制<br>Command+X 剪切<br>Command+V 粘贴<br>Command+shift+V 从剪贴板里选择粘贴<br>Command+D 向下复制一行<br>shift+delete 删除当前行<br>Control+Shift+J 清除缩进变成单行<br>shift+回车 快速换行<br>Command+回车 换行光标还在原先位置<br>Command+shift+U 大小写转换<br>Command+shift+[,Command+shift+] 文件选项卡快速切换<br>Command+加号,Command+减号 收缩代码块<br>Command+shift+加号，Command+shift+减号 收缩整个文档的代码块<br>Command+W 关闭当前文件选项卡<br>alt+单击 光标在多处定位<br>Control+shift+J 把下面行的缩进收上来<br>shift + F6 高级修改，可快速修改光标所在的标签、变量、函数等<br>alt+/ 代码补全<br>Control+G 向下选中相同的代码块，可同时编辑</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Control+alt+R 运行项目<br>Command+Control+R 运行Debug<br>Command+F8 添加断点<br>Command+shift+F8 打开断点列表</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>Command+O 跳转到某个类<br>Command+shift+O 跳转到某个文件<br>Command+alt+O 跳转到某个符号<br>Control+←,Control+→ 转到上/下一个编辑器选项卡<br>F12 打开之前打开的工具窗口（TODO、终端等）<br>Command+L 跳转行<br>Command+E 弹出最近文件<br>Command+alt+←,Command+alt+→ 向前向后导航到代码块交接处（一般是空行处）<br>Command+shift+delete 导航到上一个编辑位置的位置<br>Command+B 跳转到变量声明处<br>Control+J 获取变量相关信息（类型、注释等，注释是拿上一行的注释）<br>Command+Y 小浮窗显示变量声明时的行<br>Command+[,Command+] 光标现在的位置和之前的位置切换<br>Command+F12 文件结构弹出式菜单<br>alt+H 类的层次结构<br>F2,shift+F2 切换到上\下一个突出错误的位置<br>Command+↑ 跳转到导航栏<br>F3 添加书签<br>alt+F3 添加带助记的书签<br>alt+1,alt+2… 切换到相应助记的书签位置<br>Command+F3 打开书签列表</p>
<h2 id="VCS-本地历史记录"><a href="#VCS-本地历史记录" class="headerlink" title="VCS/本地历史记录"></a>VCS/本地历史记录</h2><p>control+V 打开VST小浮窗<br>Command+K 提交项目<br>Command+T 更新项目<br>alt+shift+C 打开最近修改列表</p>
<h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p>Command+F 搜索<br>Command+R 替换<br>Command+G 查找下一个<br>Command+shift+G 查找上一个<br>Command+shift+F 按路径搜索<br>Command+shift+R 按路径替换</p>
<h2 id="选中文字的搜索"><a href="#选中文字的搜索" class="headerlink" title="选中文字的搜索"></a>选中文字的搜索</h2><p>Command+F7 向声明的地方搜索并选中<br>Command+shift+F7 打开搜索框进行搜索<br>Command+alt+F7 打开小浮窗显示搜索列表</p>
<h2 id="对项目文件的操作（重构）"><a href="#对项目文件的操作（重构）" class="headerlink" title="对项目文件的操作（重构）"></a>对项目文件的操作（重构）</h2><p>F5 复制文件到某个目录<br>F6 移动文件到某个目录<br>Command+delete 安全删除<br>shift+F6 重命名</p>
<h2 id="全局的"><a href="#全局的" class="headerlink" title="全局的"></a>全局的</h2><p>双击shift 弹出小浮窗搜索所有<br>Command+<code>切换项目 Command+shift+</code> 反向切换项目<br>Command+shift+A 整个工程的查找操作<br>Command+1,Command+2… 打开各种工具窗口<br>alt+shift+F 把文件添加到收藏夹<br>alt+shift+I 打开项目描述<br>alt+~ 快速切换当前计划<br>Command+, 设置编辑器<br>Control+Tab 选项卡和工具窗口之间进行切换<br>alert+回车 显示npm版本升级列表</p>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 TCP 建立连接需要三次握手?</title>
    <url>/2021/12/19/%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<p>因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p>
<p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。</p>
<p>假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。</p>
<p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN Flood 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>webstorm快捷键（win版）</title>
    <url>/2021/12/12/webstorm%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88win%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>Ctrl + Space 基本代码完成 （任何类、 方法或变量名称）<br>Ctrl + Shift + Enter 完整的语句<br>Ctrl + P （在方法调用参数） 内的参数信息<br>Ctrl + Q 快速的文件查找<br>Ctrl + mouse 在简短的信息的代码<br>Ctrl + F1 在插入符号显示错误或警告的说明<br>Alt + Insert 生成代码…<br>Ctrl + Alt + T 以…（如果……否则，尝试。抓住，等等。）<br>Ctrl + / 行注释与取消注释<br>Ctrl + Shift + / 块注释与取消注释<br>Ctrl + W 选择先后提高代码块<br>Ctrl + Shift + W 减少当前所选内容到以前的状态<br>Alt + Q 上下文信息 Alt + enter 键显示意图采取行动和快速修复<br>Ctrl + Alt + L 格式化代码<br>Ctrl + Alt + I 自动缩进的行数<br>Tab / Shift + Tab 缩进/取消缩进选定的行<br>Ctrl + X , Shift + Delete 剪切到剪贴板的当前行或者所选代码块<br>Ctrl + C，Ctrl + 插入复制当前行或者所选代码块到剪贴板<br>Ctrl + V，Shift + 从剪贴板插入粘贴<br>Ctrl + Shift + V 粘贴从最近缓冲区…<br>Ctrl + D 复制当前行或者所选代码块<br>Ctrl + Y 删除线在插入符号<br>Ctrl + Shift + J 加入行<br>Ctrl + enter 键分割线<br>Shift + Enter 开始新行<br>Ctrl + Shift + U 切换案例在插入符号或所选代码块的词<br>按住 Ctrl + Shift +] / [选择直到代码块结束/开始<br>Ctrl + Delete 删除单词结束 Ctrl + 退格键删除单词的开始<br>Ctrl + 滑鼠 + /-展开/折叠代码块<br>Ctrl + Shift + 滑鼠 + 全部展开<br>Ctrl + Shift + 滑鼠-崩溃<br>Ctrl + F4 关闭活动的编辑器标签</p>
<h2 id="多个插入符号和选择"><a href="#多个插入符号和选择" class="headerlink" title="多个插入符号和选择"></a>多个插入符号和选择</h2><p>Alt + 单击添加或插入符号<br>Shift + Ctrl + Alt + J 选择全部删除按住<br>Alt + J 选择下一个出现<br>Alt + Shift + J 取消选择发生按<br>Esc 取消选择所有事件或插入符号</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>Alt + Shift + F10/F9 选择配置和运行/调试<br>Shift + F10/F9 运行/调试<br>Ctrl + Shift + F10/F9 运行/调试上下文配置从编辑器<br>Alt + Shift + R 重新运行测试</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>F8 步骤<br>F7 一步成<br>Shift + F7 智能踏入<br>Shift + F8 踏出<br>Alt + F9 运行到光标<br>Alt + F8 计算表达式的值<br>F9 简历<br>Ctrl + f8 键切换断点<br>Ctrl + Shift + F8 查看断点</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>Ctrl + N 去某个类<br>Ctrl + Shift + N 转到文件<br>Ctrl + Alt + 转变 + N 转到符号<br>Alt + 权利转到下一个编辑器选项卡<br>Alt + 左转到上一个编辑器选项卡<br>f12 键回到上一个工具窗口<br>esc 键转到编辑器 （在工具窗口中）<br>Shift + Esc 隐藏活动或最后一个活动窗口<br>Ctrl + Shift + F4 关闭活动运行/消息/查找 /……选项卡<br>Ctrl + G 转到线<br>Ctrl + E 最近文件弹出式<br>Ctrl + Alt + 左/右导航回 /转发<br>Ctrl + Shift + 退格键导航最后编辑位置<br>Alt + F1 选择当前文件或符号在任何视图中<br>Ctrl + B，<br>Ctrl + 单击转到声明<br>Ctrl + Alt + B 去实现<br>Ctrl + Shift + I，打开快速定义查找<br>Ctrl + Shift + B 去键入宣言<br>Ctrl + U 转到超级方法/超级类<br>Alt + 上下转到上一页/下一页方法<br>Ctrl +] / [移动到代码块结束/启动<br>Ctrl + f12 键文件结构弹出<br>Ctrl + H 类型层次结构<br>Ctrl + Alt + H 调用层次结构<br>F2 / Shift + F2 下一页/上一页突出显示错误 F4，<br>Ctrl + Ente 跳转到源<br>Alt + home 跳转到导航栏<br>F11 切换书签<br>Ctrl + F11 切换书签助记键<br>Ctrl + #[0-9] 去带编号的书签<br>Shift + F11 显示书签</p>
<h2 id="VCS-当地历史"><a href="#VCS-当地历史" class="headerlink" title="VCS/当地历史"></a>VCS/当地历史</h2><p>Alt + 反引号 (‘) ‘VCS’ 快速弹出<br>Ctrl + K 提交项目到 VCS<br>Ctrl + T 更新项目从 VCS<br>Alt + Shift + C 查看最近的更改</p>
<h2 id="搜索-替换"><a href="#搜索-替换" class="headerlink" title="搜索/替换"></a>搜索/替换</h2><p>Ctrl + F 查找<br>F3 查找下一步<br>Shift + F3 查找上一个<br>Ctrl + R 替换<br>Ctrl + Shift + F 在路径中找到<br>Ctrl + Shift + R 替换路径中</p>
<h2 id="使用搜索"><a href="#使用搜索" class="headerlink" title="使用搜索"></a>使用搜索</h2><p>Alt + f7 键 / Ctrl + f7 键查找使用实例 / 找到用法在文件<br>Ctrl + Shift + f7 键突出显示用法在文件<br>Ctrl + Alt + F7 显示用法</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>F5 副本<br>F6 移动<br>Alt + delete 安全删除<br>Shift + F6 重命名<br>Ctrl + Alt + N 内联可变<br>Ctrl + Alt + M 提取方法<br>Ctrl + Alt + V 引进可变<br>Ctrl + Alt + C 引入的恒定<br>Ctrl + Alt + P 介绍参数<br>Ctrl + F6 变化函数签名</p>
<h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2><p>Ctrl + Shift +a 查找操作<br>双击shift 查找所有的（包括文件、命令等）<br>Alt + #[0-9] 打开相应的工具窗口<br>Ctrl + Shift + f12 键切换最大化编辑器<br>Alt + Shift + F 将添加到收藏夹<br>Alt + Shift + I 检查当前文件与当前配置文件<br>Ctrl + 反引号 (‘) 快速切换当前计划<br>Ctrl + Alt + S 打开设置对话框<br>Ctrl + Tab 切换选项卡和工具窗口</p>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用npm安装node-sass失败的解决办法</title>
    <url>/2021/12/12/%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85node-sass%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>使用npm安装node-sass失败时，我们可以这样解决：</p>
<ul>
<li>第一步（卸载之前安装失败的包）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall node-sass -D</span><br></pre></td></tr></table></figure></li>
<li>第二步（使用淘宝镜像cnpm，先提前安装好cnpm）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm i node-sass -D</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>去掉inline-block元素间隙</title>
    <url>/2021/12/18/%E5%8E%BB%E6%8E%89inline-block%E5%85%83%E7%B4%A0%E9%97%B4%E9%9A%99/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做页面时，如果用到inline-block元素来布局，就无可避免都会遇到一个问题，就是inline-block元素之间的间隙。这些间隙会导致一些布局上的问题，需要把间隙去掉。</p>
<h2 id="1、标签写在一行，移除标签间的空格"><a href="#1、标签写在一行，移除标签间的空格" class="headerlink" title="1、标签写在一行，移除标签间的空格"></a>1、标签写在一行，移除标签间的空格</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、利用HTML注释标签"><a href="#2、利用HTML注释标签" class="headerlink" title="2、利用HTML注释标签"></a>2、利用HTML注释标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    --&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    --&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    --&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、在父容器上使用font-size-0-可以消除间隙"><a href="#3、在父容器上使用font-size-0-可以消除间隙" class="headerlink" title="3、在父容器上使用font-size:0;可以消除间隙"></a>3、在父容器上使用font-size:0;可以消除间隙</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">font-size</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.demo</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">     <span class="attribute">background</span>:<span class="number">#ddd</span>;</span><br><span class="line">     <span class="attribute">display</span>: inline-block;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="comment">/*要设置相应的字号*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域有话说</title>
    <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%9C%89%E8%AF%9D%E8%AF%B4/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>作为一名前端开发工程师，如果你不懂跨域的话，那实在说不过去啦。几乎所有的前端面试都会问到跨域相关的问题，所以跨域还是十分重要的，同时他也是比较基础的东西，话不多说，今天就来谈一谈跨域。</p>
<h2 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1.什么是跨域？"></a>1.什么是跨域？</h2><p>说到跨域，必须得提一提浏览器的“同源策略”，同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ol>
<h2 id="2-跨越问题产生的三大必备条件"><a href="#2-跨越问题产生的三大必备条件" class="headerlink" title="2.跨越问题产生的三大必备条件"></a>2.跨越问题产生的三大必备条件</h2><p>说到前端的跨域问题，不得不说产生前端跨域问题的必备条件：</p>
<ol>
<li>浏览器的限制，即请求从前端浏览器发出</li>
<li>发出的请求是XMLHttpRequest请求</li>
<li>请求的资源来自其它域，即域名不同</li>
</ol>
<p>浏览器发出的请求类型有很多（如下图）</p>
<p>很明显能看到有个选项是XHR，这就是前端的XMLHttpRequest请求了。</p>
<p>至于其它的请求类型，比如JS,CSS,Img等都不存在跨域限制访问的问题。</p>
<h2 id="3-跨域问题的解决思路"><a href="#3-跨域问题的解决思路" class="headerlink" title="3.跨域问题的解决思路"></a>3.跨域问题的解决思路</h2><p>由产生跨域问题的三大必备条件可知，我们解决跨域问题只需要破坏三大条件中的至少一个就可以了解决跨域限制访问的问题了。</p>
<h3 id="1-首先，针对浏览器层面，解除浏览器对于跨域的检查，关于如何做，请大家自行百度：”浏览器跨域设置”即可，这里不再赘述了。"><a href="#1-首先，针对浏览器层面，解除浏览器对于跨域的检查，关于如何做，请大家自行百度：”浏览器跨域设置”即可，这里不再赘述了。" class="headerlink" title="1.首先，针对浏览器层面，解除浏览器对于跨域的检查，关于如何做，请大家自行百度：”浏览器跨域设置”即可，这里不再赘述了。"></a>1.首先，针对浏览器层面，解除浏览器对于跨域的检查，关于如何做，请大家自行百度：”浏览器跨域设置”即可，这里不再赘述了。</h3><h3 id="2-正对第二个条件，如果发出的请求不是XMLHttpRequest请求，根本不存在跨域限制访问的问题，也不是我们研究的主题，这里也不再赘述了。"><a href="#2-正对第二个条件，如果发出的请求不是XMLHttpRequest请求，根本不存在跨域限制访问的问题，也不是我们研究的主题，这里也不再赘述了。" class="headerlink" title="2.正对第二个条件，如果发出的请求不是XMLHttpRequest请求，根本不存在跨域限制访问的问题，也不是我们研究的主题，这里也不再赘述了。"></a>2.正对第二个条件，如果发出的请求不是XMLHttpRequest请求，根本不存在跨域限制访问的问题，也不是我们研究的主题，这里也不再赘述了。</h3><h3 id="3-下面开始介绍由第三个条件派生出的几种常见的跨域解决方式："><a href="#3-下面开始介绍由第三个条件派生出的几种常见的跨域解决方式：" class="headerlink" title="3. 下面开始介绍由第三个条件派生出的几种常见的跨域解决方式："></a>3. 下面开始介绍由第三个条件派生出的几种常见的跨域解决方式：</h3><h4 id="a-跨域资源共享（CORS）"><a href="#a-跨域资源共享（CORS）" class="headerlink" title="a.  跨域资源共享（CORS）"></a>a.  跨域资源共享（CORS）</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。</p>
<p>上面引用阮一峰老师的日志，关于CORS的讲解，阮一峰老师讲的够细致了，这里我就不再赘述了。</p>
<h4 id="b-代理服务器实现跨域"><a href="#b-代理服务器实现跨域" class="headerlink" title="b. 代理服务器实现跨域"></a>b. 代理服务器实现跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<h5 id="（1）-非vue框架的跨域"><a href="#（1）-非vue框架的跨域" class="headerlink" title="（1） 非vue框架的跨域"></a>（1） 非vue框架的跨域</h5><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>&lt;1&gt;前端代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;中间件服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    <span class="attr">onProxyRes</span>: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">        res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        res.header(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt;Nodejs后台：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h5 id="（2）-vue框架的跨域"><a href="#（2）-vue框架的跨域" class="headerlink" title="（2） vue框架的跨域"></a>（2） vue框架的跨域</h5><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">proxy</span>: [&#123;</span><br><span class="line">            <span class="attr">context</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">secure</span>: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="attr">noInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-WebSocket协议跨域"><a href="#c-WebSocket协议跨域" class="headerlink" title="c. WebSocket协议跨域"></a>c. WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>&lt;1&gt;前端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">&quot;text&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 连接成功处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听服务端消息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听服务端关闭</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.send(<span class="built_in">this</span>.value);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;Nodejs socket后台：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="d-nginx代理跨域"><a href="#d-nginx代理跨域" class="headerlink" title="d. nginx代理跨域"></a>d. nginx代理跨域</h4><h5 id="1-nginx配置解决iconfont跨域"><a href="#1-nginx配置解决iconfont跨域" class="headerlink" title="(1). nginx配置解决iconfont跨域"></a>(1). nginx配置解决iconfont跨域</h5><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-nginx反向代理接口跨域"><a href="#2-nginx反向代理接口跨域" class="headerlink" title="(2). nginx反向代理接口跨域"></a>(2). nginx反向代理接口跨域</h5><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;1&gt; 前端代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt; Nodejs后台示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="e-通过jsonp跨域"><a href="#e-通过jsonp跨域" class="headerlink" title="e. 通过jsonp跨域"></a>e. 通过jsonp跨域</h4><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信，但是jsonp有个弊端，只支持get请求。</p>
<h5 id="1-原生实现"><a href="#1-原生实现" class="headerlink" title="(1). 原生实现"></a>(1). 原生实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">    script.src = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onBack(&#123;<span class="string">&quot;status&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-jquery-ajax："><a href="#2-jquery-ajax：" class="headerlink" title="(2). jquery ajax："></a>(2). jquery ajax：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    <span class="attr">jsonpCallback</span>: <span class="string">&quot;onBack&quot;</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(3). vue.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.jsonp(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;onBack&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端node.js代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">&#x27;(&#x27;</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>除了以上几种常用的，还有其他的解决方式，在此就不再赘述了。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之HTML5离线存储(应用程序缓存)</title>
    <url>/2021/12/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BHTML5%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTML5 提供一种 应用程序缓存 机制，使得基于web的应用程序可以离线运行。开发者可以使用 <strong>Application Cache</strong> (AppCache) 接口设定浏览器应该缓存的资源并使得离线用户可用。 在处于离线状态时，即使用户点击刷新按钮，应用也能正常加载与工作。</p>
<h2 id="简介Application-Cache"><a href="#简介Application-Cache" class="headerlink" title="简介Application Cache"></a>简介Application Cache</h2><pre><code>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。

HTML5引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势：

1. 离线浏览 - 用户可在应用离线时使用它们
2. 速度 - 已缓存资源加载得更快
3. 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。
</code></pre>
<p>HTML5提出了两大离线存储技术：localstorage与Application Cache，两者各有应用场景；传统还有离线存储技术Cookie。经过实践我们认为localstorage应该存储一些非关键性ajax数据，做锦上添花的事情；Application Cache用于存储静态资源，仍然是干锦上添花的事情；而cookie只能保存一小段文本（4096字节）；所以不能存储大数据，这是cookie与上述缓存技术的差异之一，而因为HTTP是无状态的，服务器为了区分请求是否来源于同一个服务器，需要一个标识字符串，而这个任务就是cookie完成的，这一段文本每次都会在服务器与浏览器之间传递，以验证用户的权限。所以Application Cache的应用场景不一样，所以使用也不一致。</p>
<h2 id="Cache-Manifest-基础"><a href="#Cache-Manifest-基础" class="headerlink" title="Cache Manifest 基础"></a>Cache Manifest 基础</h2><p>Application Cache的使用要做两方面的工作：</p>
<p>① 服务器端需要维护一个manifest清单</p>
<p>② 浏览器上只需要一个简单的设置即可<br>如需启用应用程序缓存，请在文档的 <code>&lt;html&gt;</code> 标签中包含 manifest 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>  <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p>
<p>manifest 文件的建议的文件扩展名是：”.appcache”。</p>
<p>请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p>
<p>如上面提到的HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<h2 id="Manifest-文件"><a href="#Manifest-文件" class="headerlink" title="Manifest 文件"></a>Manifest 文件</h2><p>在开始之前要先了解下manifest（即.appcache文件），上面的解析清单要怎么写。</p>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p>
<p>manifest 文件可分为三个部分：</p>
<ol>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存；</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存；</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）；</li>
</ol>
<p>在线的情况下,用户代理每次访问页面，都会去读一次manifest。如果发现其改变, 则重新加载全部清单中的资源。</p>
<h2 id="CACHE-MANIFEST"><a href="#CACHE-MANIFEST" class="headerlink" title="CACHE MANIFEST"></a>CACHE MANIFEST</h2><p>第一行，CACHE MANIFEST，是必需的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br></pre></td></tr></table></figure>
<p>上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。</p>
<h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h2><pre><code>白名单，使用通配符&quot;*&quot;. 则会进入白名单的open状态. 这种状态下.所有不在相关Cache区域出现的url都默认使用HTTP相关缓存头策略.
</code></pre>
<p>下面的 NETWORK 小节规定文件 “login.asp” 永远不会被缓存，且离线时是不可用的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br></pre></td></tr></table></figure>
<p>可以使用星号来指示所有其他资源/文件都需要因特网连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NETWORK:</span><br><span class="line">*</span><br><span class="line">```<span class="comment">## FALLBACK</span></span><br><span class="line">下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 <span class="string">&quot;offline.html&quot;</span> 替代 /html5/ 目录中的所有文件：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">ALLBACK:</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure>
<p>注释：第一个 URI 是资源，第二个是替补。</p>
<h3 id="尺寸限制"><a href="#尺寸限制" class="headerlink" title="尺寸限制"></a>尺寸限制</h3><p>注意：Application Cache的尺寸限制统一在5M，建议Application Cache，存储公共资源，不要存储业务资源。</p>
<h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>一旦应用被缓存，它就会保持缓存直到发生下列情况：</p>
<ol>
<li>用户清空浏览器缓存</li>
<li>manifest 文件被修改</li>
<li>由程序来更新应用缓存</li>
</ol>
<p>对于浏览器来说，manifest的加载是要晚于其他资源的，这就导致check manifest的过程是滞后的。发现manifest改变，所有浏览器的实现都是紧随着做静默更新资源，以保证下次pv，应用到更新。</p>
<p>由更新机制来说，首次更新manifest时，因为页面加载已经开始甚至已经完成，缓存更新尚未完成，浏览器仍然会使用过期的资源；浏览器是当Application Cache有更新时，该次不会使用新资源，第二次才会使用。这个时候update事件中执行window.reload事件。</p>
<p>这里，我们来看看更新manifest会走的一些流程：<br><a href="https://img-blog.csdnimg.cn/20190518181908959.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190518181908959.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<h3 id="缓存立即执行"><a href="#缓存立即执行" class="headerlink" title="缓存立即执行"></a>缓存立即执行</h3><p>我们的产品已经更新了用户却要第二次进来才能够看到，这样用户体验也太差了吧，有什么方式能够解决呢？好在html5给javascript提供了相关的API。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	applicationCache.swapCache();</span><br><span class="line">	location.reload();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>站点离线存储的容量限制是5M；</li>
<li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存；</li>
<li>引用manifest的html必须与manifest文件同源，在同一个域下；</li>
<li>在manifest中使用的相对路径，相对参照物为manifest文件；</li>
<li>CACHE MANIFEST字符串应在第一行，且必不可少；</li>
<li>系统会自动缓存引用清单文件的 HTML 文件；</li>
<li>manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面；</li>
<li>FALLBACK中的资源必须和manifest文件同源；</li>
<li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源；</li>
<li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问；</li>
<li>当manifest文件发生改变时，资源请求本身也会触发更新。</li>
</ol>
<p>在此刻使用这里描述的应用程序缓存功能高度不鼓励; 它正在处于从Web平台中被删除的过程。请改用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" title="Service Workers">Service Workers</a> 代替。事实上，在Firefox 44中，当AppCache用于为页面提供离线支持时，控制台中现在显示一条警告消息，建议开发人员改用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" title="Service Workers">Service Workers</a> 代替。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>本地搭建ChatGPT</title>
    <url>/2023/07/30/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAChatGPT/</url>
    <content><![CDATA[<p>1.下载并安装Docker 【<a href="https://www.docker.com/" title="官网下载">官网下载</a>】</p>
<p>2.使用开源项目：潘多拉 (<a href="https://github.com/pengzhile/pandora" title="Pandora">Pandora</a>)</p>
<p>3.一键安装命令(注意以下步骤如果安装不成功，有可能需要科学上网)：<br>先执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull pengzhile/pandora</span><br></pre></td></tr></table></figure>

<p>然后再执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora</span><br></pre></td></tr></table></figure>

<p>4.登录自己的chatgpt，然后获取自己的 Access TOKEN：<a href="http://chat.openai.com/api/auth/session">http://chat.openai.com/api/auth/session</a><br>有了Access TOKEN，则可以半个月之内免登录。</p>
<p>5.访问本地链接：<a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a> 即可搞定！</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>查看git的某个分支是基于哪个分支拉的</title>
    <url>/2022/01/01/%E6%9F%A5%E7%9C%8Bgit%E7%9A%84%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%B8%AA%E5%88%86%E6%94%AF%E6%8B%89%E7%9A%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用git管理代码仓库的时候，经常会遇见一件头疼的事情，就是随着项目的持续迭代，git的分支越拉越多，这时候很容易造成分支管理的混乱，比如你在分支A开发功能，然后改bug需要切换到另一个分支B，切来切去，就会产生混乱。这时候如果能理清各个分支之间的关系就很好办了，比如分支A来自哪里，分支B又来自哪个分支拉出来的。今天告诉你答案，只需要一行代码就可以知道某个分支是基于哪个分支拉出来的，请看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog --date=<span class="built_in">local</span> | grep &lt;branchname&gt;</span><br></pre></td></tr></table></figure>

<p>这个问题最原始的出处是StackOverflow，可以看看这个问题，看完你就懂了<a href="https://stackoverflow.com/questions/2255416/how-to-determine-when-a-git-branch-was-created">How to determine when a Git branch was created?</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>正确认识typescript中的泛型</title>
    <url>/2022/01/15/%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86typescript%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h1><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<p>设想这样一个场景，你想设计一个函数,函数有两个参数，并且这两个参数的类型是相同的，也就是说第一个参数如果传string类型，那么要求第二个参数也必须是string类型的，如果第一个参数是number类型的，那么第二个参数也必须是number类型的，那么怎么做到呢？我们不妨先使用JavaScript来声明此函数试一试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js声明函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addUseJS</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">addUseJS(<span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">addUseJS(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jery&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如此做法，并不能达到我们的要求，你可能会想到在函数内部做一层参数的类型判断，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加了参数类型判断的声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addUseJS</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> a</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> b === type &amp;&amp; [<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;string&#x27;</span>].includes(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数类型不符合要求&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">addUseJS(<span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">addUseJS(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jery&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如此做法不仅繁琐，而且在编码阶段，并不能提醒开发者应该提示的错误。如果我们需要在开发者编码阶段就提示相应的错误，那么就需要使用typescript隆重登场了。<br>我们先使用typescript来重构此函数，初学typescript的选手可能写出如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: number | string, b: number | string</span>): (<span class="params">number | string</span>)[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此写不仅繁琐，而且可读性和优雅性也很差，那么我们怎样来限制两个参数的类型一致呢？这时候使用typescript中的泛型来解决这个问题是最合适不过的了。泛型顾名思义就是泛指的类型，那么我们使用泛型来重构这个函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数名后面紧跟着一对尖括号<code>&lt;&gt;</code>里面写上一个占位符 T（当然你写其他的命名也可以，比如你使用abc，ab123等等js中正确的命名方式都可以）。声明完成之后，就代表 add 这个函数在调用的时候，传入的两个参数类型必须一致，都是 T 类型，返回值为一个数组，数组中的成员都为 T 类型，否则 ts 编译器就会提示报错信息，这样就在开发者写代码的阶段直接的规避了一些错误。<br>使用泛型声明完成之后，这样我们在调用的时候就可以显式的传入泛型的类型，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用add函数</span></span><br><span class="line">add&lt;number&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">add&lt;string&gt;(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line">add&lt;object&gt;(&#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;jerry&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们想传入什么类型都可以，只要在函数名后面的尖括号<code>&lt;&gt;</code>里面写上泛型 T 所代表的类型即可。</p>
<h2 id="使用多个泛型类型"><a href="#使用多个泛型类型" class="headerlink" title="使用多个泛型类型"></a>使用多个泛型类型</h2><p>泛型不止可以传入一个，也可以传入多个泛型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入多个泛型</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a: T, b: U</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> [b ,a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">mutiple&lt;string, number&gt;(<span class="string">&#x27;tom&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">mutiple&lt;number, object&gt;(<span class="number">123</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;jerry&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>泛型不仅可以限制参数的类型，也可以用来限制返回结果的类型。</strong><br>注：<br>本文demo的github仓库地址：<a href="https://github.com/webRambler/react-ts-practice" title="泛型介绍">泛型介绍</a><br>文件：<code>src/generic/function-generic.ts</code></p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端按钮点击背景高亮解决之法</title>
    <url>/2021/12/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E8%83%8C%E6%99%AF%E9%AB%98%E4%BA%AE%E8%A7%A3%E5%86%B3%E4%B9%8B%E6%B3%95/</url>
    <content><![CDATA[<p>在移动端上，有事件监听的元素被点击的时候会被高亮显示，而-webkit-tap-highlight-color属性会在当用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色。</p>
<p>对于添加了 cursor:pointer 属性的元素，在移动端点击时，背景会高亮。为元素添加 -webkit-tap-highlight-color: transparent; 属性可以隐藏背景高亮。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析Javascript继承</title>
    <url>/2021/12/13/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Javascript%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h2><p>此种继承方式的基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.prop = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.getProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subProp = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  Son.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">  Son.prototype.getSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subProp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> Son</span><br><span class="line">  <span class="built_in">console</span>.log(instance)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190309220650549.png"><img src="https://img-blog.csdnimg.cn/20190309220650549.png"></a></p>
<p>使用此方法实现要注意一点：若在重写原型链之前创建对象，则这个对象不会拥有后面重写原型链之后的方法和属性，我们看下一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.prop = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.getProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subProp = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">new</span> Son()</span><br><span class="line">  </span><br><span class="line">  Son.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">  Son.prototype.getSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subProp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> Son</span><br><span class="line">  <span class="built_in">console</span>.log(s, <span class="string">&#x27;重写原型链之前&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(instance, <span class="string">&#x27;重写原型链之后&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190309221145831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190309221145831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>可以很明显的看到，重写原型链之前创建的对象s的原型并不会属性prop和方法getSubProp，所以，如果你要用此方法来实现继承，请务必在重写原型链之后再创建新对象。</p>
<h3 id="原型链的问题："><a href="#原型链的问题：" class="headerlink" title="原型链的问题："></a>原型链的问题：</h3><p>（1）原型链实现继承，最主要的问题来自包含引用类型值的原型，请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Son.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="keyword">new</span> Son()</span><br><span class="line">  s1.colors.push(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(s1)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="keyword">new</span> Son()</span><br><span class="line">  <span class="built_in">console</span>.log(s2)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/2019031000125533.png"><img src="https://img-blog.csdnimg.cn/2019031000125533.png"></a></p>
<p>可以很明显的看到，第二次创建的实例s2的原型中的属性colors中也有了”green”。其实，引用类型值的原型属性会被所有实例共享，而这也正是为什么要在构造函数中，而不是再原型对象中定义属性的原因。</p>
<p>（2）原型链的第二个问题是：再创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<p>基于以上两点，我们一般不建议使用原型链的方式实现继承，实际上大多数人也不会单独采用这种方式。</p>
<h2 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h2><p>在解决原型中包含引用类型值带来问题的过程中，开发人员开始使用一种叫做“借用构造函数”的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数内部调用超类型构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.list = [<span class="string">&#x27;football&#x27;</span>, <span class="string">&#x27;baseball&#x27;</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent.call(<span class="built_in">this</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> instance1 = <span class="keyword">new</span> Son()</span><br><span class="line"> instance1.list.push(<span class="string">&#x27;tennis&#x27;</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(instance1)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> instance2 = <span class="keyword">new</span> Son()</span><br><span class="line"> <span class="built_in">console</span>.log(instance2)</span><br></pre></td></tr></table></figure>

<p>输入如下：<br><a href="https://img-blog.csdnimg.cn/20190310002410271.png"><img src="https://img-blog.csdnimg.cn/20190310002410271.png"></a></p>
<p>可以很明显的看到，实例中的引用类型值不再互相影响，由此解决原型链实现继承带来的引用类型值的问题。此外，相比原型链而言，借用构造函数还有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent.call(<span class="built_in">this</span>, <span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">   <span class="built_in">this</span>.age = <span class="number">15</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> instance = <span class="keyword">new</span> Son()</span><br><span class="line"> <span class="built_in">console</span>.log(instance)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190310003001620.png"><img src="https://img-blog.csdnimg.cn/20190310003001620.png"></a></p>
<p>这里我们要提醒各位的是，为了确保超类型构造函数不会重写子类型的属性，所以我们建议，请在调用超类型构造函数之后，再添加子类型中定义的属性。</p>
<h3 id="借用构造函数的问题："><a href="#借用构造函数的问题：" class="headerlink" title="借用构造函数的问题："></a>借用构造函数的问题：</h3><p>很明显的可以发现，这种模式实现的继承，子类型无法获得超类型的原型中定义的属性和方法。基于上述考虑，我们一般也很少单独使用此种方式实现继承。</p>
<h2 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3. 组合式继承"></a>3. 组合式继承</h2><p>组合继承，有时候也叫伪经典继承，指的是通过将原型链和借用构造函数的技术组合在一起，取二者之所长实现继承的一种技术。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。由此，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性。请看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  superType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    superType.call(<span class="built_in">this</span>, name)</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subType.prototype = <span class="keyword">new</span> superType()</span><br><span class="line">  subType.prototype.constructor = subType</span><br><span class="line">  subType.prototype.sayAge = <span class="function"><span class="params">_</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.age)&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> sub1 = <span class="keyword">new</span> subType(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">15</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(sub1)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190310004502401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190310004502401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<h3 id="组合式继承的问题："><a href="#组合式继承的问题：" class="headerlink" title="组合式继承的问题："></a>组合式继承的问题：</h3><p>组合式继承虽然融合了原型链和借用构造函数两者的优势，解决了二者单独使用时带来的问题，但是此种方式也不是完美无缺的。我们观察上述输出，不难发现，此种方式实现继承的过程中，调用了两次超类型构造函数；一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。进而就出现了，就上述例子来说，可以发现超类型构造函数中的属性colors和name，既出现在子类实例属性中，也出现在子类原型链上。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h2><p>利用ES5新增的方法Object.create()实现原型式继承，这个方法接收两个参数：第一个参数用于作为新对象的原型，第二个参数（可选）用于为新对象定义额外的属性；其中，第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的属性描述符定义的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">area</span>: <span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [<span class="string">&#x27;football&#x27;</span>, <span class="string">&#x27;baseball&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="built_in">Object</span>.create(person)</span><br><span class="line">  <span class="built_in">console</span>.log(p)</span><br></pre></td></tr></table></figure>

<p>输入如下：<br><a href="https://img-blog.csdnimg.cn/20190309215504188.png"><img src="https://img-blog.csdnimg.cn/20190309215504188.png"></a></p>
<p>使用此种方式实现继承，所带来的问题和原型链方式一样，同样是引用类型值的问题。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>此种方式的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象。请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [<span class="string">&#x27;baseball&#x27;</span>, <span class="string">&#x27;football&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = create(person)</span><br><span class="line">  p.sayName()   <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure>

<p>此种方式与构造函数模式类似，无法做到函数复用而降低效率。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。此种方式弥补了组合式继承方式带来的缺陷，请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">    <span class="built_in">this</span>.pi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  superType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    superType.call(<span class="built_in">this</span>, name)</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subType.prototype = <span class="built_in">Object</span>.create(superType.prototype)</span><br><span class="line">  subType.prototype.constructor = subType</span><br><span class="line">  subType.prototype.sayAge = <span class="function"><span class="params">_</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.age)&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> sub1 = <span class="keyword">new</span> subType(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">15</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(sub1)</span><br></pre></td></tr></table></figure>

<p>输出如下：<br><a href="https://img-blog.csdnimg.cn/20190310023252240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190310023252240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkyMDk1Mw==,size_16,color_FFFFFF,t_70"></a></p>
<p>可以很明显的看出，此种方式只调用一次超类型构造函数，因此避免了在原型链上创建多余的属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业界普遍认为寄生组合式继承是引用类型最理想的继承模式。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式（发布-订阅模式，消息机制）</title>
    <url>/2021/12/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="观察者模式简介"><a href="#观察者模式简介" class="headerlink" title="观察者模式简介"></a>观察者模式简介</h2><p><strong>观察者模式</strong>（Observer）又被称作<strong>发布-订阅模式</strong>或<strong>消息机制</strong>，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<p>发布-订阅模式可以广泛的用于异步编程中，这是一种替代传统回调函数的方案。比如，我们可以订阅ajax请求的error，success等事件，在请求出错或者成功的时候做一些逻辑处理。或者如果想在动画的每一帧完成之后做一些事情，那我们就可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们无需过多的关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p>
<p>发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式的调用另一个对象的某个接口，此模式让两个对象松耦合的联系在一起，虽然不清楚彼此内部的细节，但这也不影响他们之间的相互通信。当有新的订阅者出现时，发布者的代码不需要做任何的修改；同样的，发布者需要改变时，也不影响之前的订阅者，只要之前约定的事件名称没有发生改变，就可以自由的改变他们。</p>
<h2 id="创建观察者模式的过程"><a href="#创建观察者模式的过程" class="headerlink" title="创建观察者模式的过程"></a>创建观察者模式的过程</h2><p>我们想要把观察者对象创建出来，首先我们需要一个用于存放消息的容器对象（也被称作“消息容器”）和三个方法，分别是订阅消息方法、取消订阅消息的方法、发送订阅消息的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Observer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> eventList = &#123;&#125;,</span><br><span class="line">      subscribe,</span><br><span class="line">      publish,</span><br><span class="line">      remove;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    subscribe,</span><br><span class="line">    publish,</span><br><span class="line">    remove</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>此即为发布-订阅模式的雏形。接下来我们来一一实现这三个方法：</p>
<p>首先，订阅消息的方法subscribe，订阅消息，首先我们需要知道订阅得消息名称，所以分析得知需要一个参数来代表订阅的消息名称，然后订阅了这个消息，总得知道订阅了之后要做什么事情吧，所以，我们还需要一个回调函数作为第二个参数用来表明此消息发布时所要做的事情。由此，请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> eventList[key] == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    eventList[key] = []</span><br><span class="line">  &#125;</span><br><span class="line">  eventList[key].push(fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，来看取消订阅的方法remove，这个应该不难想象，第一个参数自然为要取消订阅的消息名称，第二个参数如果有的话，则为要取消订阅的方法，如果没有，则取消此消息的所有回调函数，请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!eventList[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fns = eventList[key]</span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    fns.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = fns.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fns[i] === fn) &#123;</span><br><span class="line">      fns.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来看最重要的发布消息的方法：对于发布消息的方法，其作用是当观察者发布一个消息时将所有的订阅者订阅的消息一次性执行。故消息名称的参数是必须的，否则不知道要发布哪个消息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">publish = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!eventList[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fns = eventList[key],</span><br><span class="line">      args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">    fns[i].apply(<span class="built_in">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经完成了发布-订阅模式的对象模型，让我们看一下完整的代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Observer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> eventList = &#123;&#125;,</span><br><span class="line">      subscribe,</span><br><span class="line">      publish,</span><br><span class="line">      remove;</span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> eventList[key] == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      eventList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    eventList[key].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布事件</span></span><br><span class="line">  publish = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!eventList[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = eventList[key],</span><br><span class="line">        args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">      fns[i].apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!eventList[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = eventList[key]</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      fns.length = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = fns.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fns[i] === fn) &#123;</span><br><span class="line">        fns.splice(i, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    subscribe,</span><br><span class="line">    publish,</span><br><span class="line">    remove</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>接下来让我们一起验证一下吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Observer.subscribe(<span class="string">&#x27;food&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我想吃香蕉&#x27;</span>, num)</span><br><span class="line">&#125;)</span><br><span class="line">Observer.subscribe(<span class="string">&#x27;food&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我想吃苹果&#x27;</span>, n, m)</span><br><span class="line">&#125;)</span><br><span class="line">Observer.subscribe(<span class="string">&#x27;food&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我想吃凤梨&#x27;</span>, m)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observer.publish(<span class="string">&#x27;food&#x27;</span>, <span class="number">36</span>, <span class="number">37</span>)</span><br></pre></td></tr></table></figure>
<p>查看控制台打印结果：<br><a href="https://img-blog.csdnimg.cn/201910111948363.png"><img src="https://img-blog.csdnimg.cn/201910111948363.png"></a></p>
<p>可以看到，三个人分别先后订阅了food的消息，然后发布的时候大家订阅的消息回调也都得到了执行。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>记录开发过程中一些常用的正则</title>
    <url>/2022/01/01/%E8%AE%B0%E5%BD%95%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alphabets: <span class="regexp">/^[A-Za-z]+$/</span></span><br><span class="line"> </span><br><span class="line">bankAccount: <span class="regexp">/^([1-9]&#123;1&#125;)(\d&#123;15&#125;|\d&#123;16&#125;|\d&#123;18&#125;)$/</span></span><br><span class="line"> </span><br><span class="line">currency: <span class="regexp">/^(([1-9]\d*)|0)(\.\d&#123;0,2&#125;)?$/</span></span><br><span class="line"> </span><br><span class="line">email: <span class="regexp">/^(([^&lt;&gt;()\[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()\[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">identity: <span class="regexp">/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/</span></span><br><span class="line"> </span><br><span class="line">ipAddress: <span class="regexp">/^((25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))\.)&#123;3&#125;(25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))$/</span></span><br><span class="line"> </span><br><span class="line">lowerCase: <span class="regexp">/^[a-z]+$/</span></span><br><span class="line"> </span><br><span class="line">ltrim: <span class="regexp">/(^\s*)/</span></span><br><span class="line"> </span><br><span class="line">mobile: <span class="regexp">/^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(1[6|7|8][0-9]))\d&#123;8&#125;$/</span></span><br><span class="line"> </span><br><span class="line">negInt: <span class="regexp">/^-[1-9]\d*$/</span></span><br><span class="line"> </span><br><span class="line">password: <span class="regexp">/^[a-zA-Z0-9]&#123;6,16&#125;$/</span></span><br><span class="line"> </span><br><span class="line">phone: <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;(-\d&#123;3,5&#125;)&#123;0,1&#125;)|(((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(1[6|7|8][0-9]))\d&#123;8&#125;)$/</span></span><br><span class="line"> </span><br><span class="line">posInt: <span class="regexp">/^[1-9]\d*$/</span></span><br><span class="line"> </span><br><span class="line">quantity: <span class="regexp">/^(([1-9]\d*)|0)(\.\d*)?$/</span></span><br><span class="line"> </span><br><span class="line">rtrim: <span class="regexp">/(\s*$)/</span></span><br><span class="line"> </span><br><span class="line">staffNumber: <span class="regexp">/^[0-9A-Za-z]&#123;1,6&#125;$/</span></span><br><span class="line"> </span><br><span class="line">tel: <span class="regexp">/^0\d&#123;2,3&#125;-\d&#123;7,8&#125;(-\d&#123;3,5&#125;)&#123;0,1&#125;$/</span></span><br><span class="line"> </span><br><span class="line">trim: <span class="regexp">/(^\s*)|(\s*$)/</span></span><br><span class="line"> </span><br><span class="line">upperCase: <span class="regexp">/^[A-Z]+$/</span></span><br><span class="line"> </span><br><span class="line">url: <span class="regexp">/^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]&#123;2&#125;))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?&#x27;\\+&amp;%$#=~_-]+))*$/</span></span><br><span class="line"> </span><br><span class="line">username: <span class="regexp">/^[a-zA-Z0-9]([a-zA-Z0-9_]&#123;4,19&#125;)+$/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
</search>
